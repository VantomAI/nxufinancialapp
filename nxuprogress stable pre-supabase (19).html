<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <!-- Updated tab title -->
  <title>Make Some Progress</title>
  <script type="text/javascript" nonce="a9f2e20cfa6e4589b1937d496e8" src="//local.adguard.org?ts=1756312402334&amp;type=content-script&amp;dmn=chatgpt.com&amp;url=https%3A%2F%2Fchatgpt.com%2Fbackend-api%2Festuary%2Fcontent%3Fid%3Dfile-U3AREEZUppHWFGTNCFw9Fu%26ts%3D487865%26p%3Dfs%26cid%3D1%26sig%3D4f229657b3c603a8a7ee5eac25854b2ed9cfb2e424ad6fb5d0d42c44eeb5dde5&amp;app=chrome.exe&amp;css=2&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1&amp;stealth=1&amp;st-dnt"></script><script type="text/javascript" nonce="a9f2e20cfa6e4589b1937d496e8" src="//local.adguard.org?ts=1756312402334&amp;name=AdGuard%20Extra&amp;name=AdGuard%20Popup%20Blocker&amp;type=user-script"></script><script src="https://cdn.tailwindcss.com"></script>
  <!-- Supabase client library -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #004c4c; /* Darkest Teal */
      color: #ffffff; /* White text */
    }
    
    /* Reusable Component Styles from the Dashboard Theme */
    .card {
        background-color: #006666; /* Dark Teal */
        border: 1px solid #008080; /* Teal */
        border-radius: 0.75rem;
        transition: all 0.3s ease-in-out;
    }
    .btn {
        border-radius: 0.375rem;
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    }
    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    .btn-primary {
        background-color: #b2d8d8; /* Lightest Teal */
        color: #004c4c; /* Darkest Teal for text */
    }
    .btn-primary:hover {
        background-color: #c0dede;
    }
    .btn-secondary {
        background-color: #008080; /* Teal */
        color: #ffffff;
        border: 1px solid #66b2b2; /* Lighter Teal */
    }
    .btn-secondary:hover {
        background-color: #66b2b2;
    }
    .btn-danger {
        background-color: #991b1b;
        color: #fef2f2;
        border-color: #7f1d1d;
    }
    .btn-danger:hover {
        background-color: #b91c1c;
    }
    .modal-content {
        background-color: #006666;
        border: 1px solid #008080;
        animation: scaleIn 0.3s ease-out forwards;
    }
    
    input, select, textarea {
        background-color: transparent;
        border: 1px solid #008080;
        border-radius: 0.375rem;
        padding: 0.5rem 0.75rem;
        width: 100%;
        transition: all 0.2s ease-in-out;
    }
    select option {
        background-color: #006666;
        color: #ffffff;
    }
    input:focus, select:focus, textarea:focus {
        outline: 2px solid #66b2b2;
        outline-offset: 2px;
        border-color: #66b2b2;
    }
    input[type="checkbox"] {
        width: 1rem;
        height: 1rem;
    }
    .progress-bar-background { background-color: #008080; }
    .progress-bar-fill { 
        background-color: #b2d8d8; 
        transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out;
    }

    /* Tab Styles */
    .tabs { display: flex; gap: 4px; margin-bottom: 16px; flex-wrap: wrap; border-bottom: 1px solid #008080; }
    .tab-btn { background-color: transparent; border: none; border-bottom: 3px solid transparent; color: #94a3b8; padding: 8px 12px; cursor: pointer; border-radius: 4px 4px 0 0; font-weight: 500; transition: all 0.2s ease-in-out; }
    .tab-btn.active { color: #b2d8d8; border-bottom-color: #b2d8d8; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* Calendar Styles */
    #calendar { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; sm:gap: 5px; }
    .calendar-day { background-color: #005c5c; border-radius: 6px; padding: 4px; min-height: 80px; font-size: 10px; sm:font-size: 12px; sm:min-height: 100px; sm:padding: 8px; }
    .calendar-day.other-month { background-color: #005252; opacity: 0.6; }
    .calendar-day .day-number { font-weight: bold; }
    .calendar-day.today .day-number {
        border: 2px solid #b2d8d8;
        background-color: #008080;
        border-radius: 50%;
        width: 1.75em;
        height: 1.75em;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .calendar-day .event { font-size: 9px; sm:font-size: 11px; padding: 2px 4px; border-radius: 4px; margin-top: 4px; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .event-bill { background-color: #008080; color: #e0f2f1; }
    .event-goal { background-color: #b2d8d8; color: #004c4c; }


    /* Edit Mode & Drag-and-Drop Styles */
    body:not(.edit-mode) .editing-controls {
        display: none;
    }
    .list-item-draggable {
        cursor: grab;
    }
    .item-dragging {
        opacity: 0.5;
        background: #008080;
    }

    /* Animations */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    .fade-in-up {
        animation: fadeInUp 0.5s ease-out forwards;
    }
    @keyframes scaleIn {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
  </style>
</head>
<body class="p-2 sm:p-4">
  <div class="container mx-auto">
    <header class="flex flex-wrap justify-between items-center mb-6 gap-4">
      <!-- Updated page header title -->
      <h1 class="text-2xl sm:text-3xl font-bold">Make Some Progress</h1>
      <div class="actions flex items-center gap-2 flex-wrap">
        <button class="btn btn-secondary" id="editDashboardBtn">Edit Dashboard</button>
        <button class="btn btn-primary editing-controls" id="addRowBtn">+ Add New Row</button>
        <button class="btn btn-secondary" id="exportBtn">Export Data</button>
        <!-- Button to export data to a text file for LLM analysis -->
        <button class="btn btn-secondary" id="exportTextBtn">Export Text</button>
        <label id="importBtn" class="btn btn-secondary">Import Data <input type="file" id="importFile" class="hidden" accept=".json"></label>
        <button class="btn btn-danger" id="resetBtn">Reset All Data</button>
        <!-- Authentication button -->
        <button class="btn btn-secondary" id="authBtn">Log in/Sign Up</button>
        <!-- Manual save data button -->
        <button class="btn btn-secondary" id="saveToCloudBtn">Save Data</button>
      </div>
    </header>

    <!-- Tab Navigation -->
    <div class="tabs">
      <button class="tab-btn active" data-tab="dashboard-tab">Dashboard</button>
      <button class="tab-btn" data-tab="check-logs-tab">Check Logs</button>
      <button class="tab-btn" data-tab="bills-tab">Recurring Bills</button>
      <button class="tab-btn" data-tab="calendar-tab">Calendar</button>
      <button class="tab-btn" data-tab="search-tab">Bill History</button>
    </div>

    <!-- Tab Content Area -->
    <div id="tab-contents">
        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div id="emptyState" class="text-center py-24 px-4 card">
                <h2 class="text-xl font-semibold mb-2">Welcome to Your Progress Dashboard</h2>
                <p class="text-slate-300 mb-4">Start by adding your first row and tracker.</p>
                <button class="btn btn-primary" id="addFirstRowBtn">Customize Dashboard</button>
            </div>
            <div id="dashboard" class="space-y-4"></div>
        </div>

        <!-- Check Logs Tab -->
        <div id="check-logs-tab" class="tab-content">
            <div class="card p-4">
                <div class="flex flex-col sm:flex-row flex-wrap justify-between items-center gap-4">
                <h3 class="text-lg font-semibold">New Check Log</h3>
                <div class="flex gap-2 flex-wrap items-center">
                    <label class="text-sm flex items-center gap-2">
                        Paycheck Date:
                        <input type="date" id="newCheckDate" class="text-sm px-2 py-1 rounded-md bg-transparent border border-teal-600">
                    </label>
                    <button class="btn btn-primary" id="addCheckBtn">+ Log Paycheck</button>
                </div>
                </div>
            </div>
            <div id="checkLogHistory" class="mt-4 space-y-4"></div>
        </div>

        <!-- Recurring Bills Tab -->
        <div id="bills-tab" class="tab-content">
            <div class="card p-4">
                <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
                    <h3 class="text-lg font-semibold">Manage Recurring Bills</h3>
                    <div class="flex items-center gap-2">
                        <button class="btn btn-secondary whitespace-nowrap" id="addBillBtn" style="white-space: nowrap;">+ New Bill</button>
                        <!-- Sort selector for bills -->
                        <label for="billSortSelect" class="text-sm">Sort by:</label>
                        <select id="billSortSelect" class="text-sm bg-teal-700 text-white p-1 rounded">
                            <option value="name">Bill Name</option>
                            <option value="amount">Amount</option>
                            <option value="dueDay">Due Day</option>
                            <option value="category">Category</option>
                        </select>
                        <select id="billSortOrder" class="text-sm bg-teal-700 text-white p-1 rounded">
                            <option value="asc">Asc</option>
                            <option value="desc">Desc</option>
                        </select>
                    </div>
                </div>
                <div class="overflow-x-auto">
                <table id="billsTable" class="w-full text-sm">
                    <thead>
                    <tr class="border-b border-teal-800">
                        <th class="p-2 text-left font-semibold">Bill Name</th>
                        <th class="p-2 text-left font-semibold">Amount</th>
                        <th class="p-2 text-left font-semibold">Due Day</th>
                        <th class="p-2 text-left font-semibold">Category</th>
                        <th class="p-2 text-left font-semibold">Type</th>
                        <th class="p-2 text-left font-semibold">Total to Pay</th>
                        <th class="p-2 text-left font-semibold">Actions</th>
                    </tr>
                    </thead>
                    <tbody id="billsBody"></tbody>
                </table>
                </div>
            </div>
        </div>

        <!-- Calendar Tab -->
        <div id="calendar-tab" class="tab-content">
            <div class="card p-4">
                <div class="flex justify-between items-center mb-4">
                    <button id="prevMonth" class="btn btn-secondary">&lt;</button>
                    <h3 id="calendar-header" class="text-lg sm:text-xl font-semibold text-center">Month Year</h3>
                    <button id="nextMonth" class="btn btn-secondary">&gt;</button>
                </div>
                <div id="calendar-grid-header" class="grid grid-cols-7 text-center mb-2 font-bold text-slate-300 text-xs sm:text-base">
                    <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                </div>
                <div id="calendar"></div>
            </div>
        </div>

        <!-- Bill History Search Tab -->
        <div id="search-tab" class="tab-content">
            <div class="card p-4">
                <h3 class="text-lg font-semibold mb-4">Bill Payment History</h3>
                <select id="billSearchSelect" class="mb-4"></select>
                <div id="billHistoryResults"></div>
            </div>
        </div>
    </div>
  </div>
  
  <!-- Modals -->
  <div id="tileModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4">
    <div class="modal-content card p-6 w-full max-w-lg">
      <h2 id="modalTitle" class="text-xl font-semibold mb-4">Add New Tracker</h2>
      <div class="form-group">
        <label class="text-sm font-medium text-slate-300 mb-2 block">Choose Template</label>
        <div class="template-selector grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4"></div>
      </div>
      <div id="templateFields"></div>
      <div class="actions flex justify-end gap-2 mt-6">
        <button class="btn btn-secondary" onclick="hideModal('tileModal')">Cancel</button>
        <button class="btn btn-primary" id="saveTileBtn">Save</button>
      </div>
    </div>
  </div>

  <div id="confirmModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4">
    <div class="modal-content card p-6 w-full max-w-md">
      <h2 id="confirmModalTitle" class="text-xl font-semibold mb-2">Are you sure?</h2>
      <p id="confirmModalText" class="text-slate-300 mb-6">This action cannot be undone.</p>
      <div class="actions flex justify-end gap-2">
        <button class="btn btn-secondary" id="confirmCancelBtn">Cancel</button>
        <button class="btn btn-danger" id="confirmOkBtn">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Authentication Modal -->
  <div id="authModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4">
    <div class="modal-content card p-6 w-full max-w-sm">
      <h2 id="authModalTitle" class="text-xl font-semibold mb-4">Log In</h2>
      <!-- Login Form -->
      <form id="loginForm" class="space-y-4">
        <div>
          <label class="text-sm font-medium text-slate-300 mb-2 block" for="loginEmail">Email</label>
          <input type="email" id="loginEmail" name="loginEmail" />
        </div>
        <div>
          <label class="text-sm font-medium text-slate-300 mb-2 block" for="loginPassword">Password</label>
          <input type="password" id="loginPassword" name="loginPassword" />
        </div>
        <button type="button" class="btn btn-primary w-full" id="loginSubmitBtn">Log In</button>
      </form>
      <!-- Signup Form -->
      <form id="signupForm" class="space-y-4 hidden">
        <div>
          <label class="text-sm font-medium text-slate-300 mb-2 block" for="signupEmail">Email</label>
          <input type="email" id="signupEmail" name="signupEmail" />
        </div>
        <div>
          <label class="text-sm font-medium text-slate-300 mb-2 block" for="signupPassword">Password</label>
          <input type="password" id="signupPassword" name="signupPassword" />
        </div>
        <div>
          <label class="text-sm font-medium text-slate-300 mb-2 block" for="signupConfirmPassword">Confirm Password</label>
          <input type="password" id="signupConfirmPassword" name="signupConfirmPassword" />
        </div>
        <button type="button" class="btn btn-primary w-full" id="signupSubmitBtn">Create Account</button>
      </form>
      <div class="flex justify-between items-center mt-4">
        <button type="button" id="toggleAuthBtn" class="text-sm text-teal-200 underline">Create Account</button>
        <button type="button" class="btn btn-secondary" onclick="hideAuthModal()">Close</button>
      </div>
    </div>
  </div>
  
  <script>
    // --- Combined State Management ---
    const STORAGE_KEY = 'unified-financial-dashboard-v1';
    const OLD_DASHBOARD_KEY = 'universal-tracker-v2';
    const OLD_CHECKLOG_KEY = 'checklog-app-v1';

    let state = {};

    const DEFAULT_STATE = {
      dashboard: {
        rows: [],
        tiles: {},
        nextRowId: 1,
        nextTileId: 1,
        isEditing: false
      },
      checkTracker: {
        bills: [],
        checkLogs: [],
      },
      calendar: {
        currentDate: new Date().toISOString()
      }
    };

    // --- Supabase Client & Config ---
    // Define your Supabase project URL and anonymous key. These values come
    // from your Supabase project settings. They enable the client to
    // authenticate and access your database. Without these the
    // authentication and data sync features will not work.
    const SUPABASE_URL = 'https://dxcvbuwjgswupqyijhav.supabase.co';
    // Supabase anon public key provided by your project settings. Replace this
    // value if you rotate your anon key in the future.
    const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR4Y3ZidXdqZ3N3dXBxeWlqaGF2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyMDgzODMsImV4cCI6MjA3MDc4NDM4M30.fAocl5EEjrqLyY52n95TikqJYu1Injje-FlKtPR6Sjg';
    // Namespace for Supabase integration state
    const NXU_SB = {};
    window.__nxu = NXU_SB; // Expose for debugging
    NXU_SB.SUPABASE_URL = SUPABASE_URL;
    NXU_SB.SUPABASE_ANON = SUPABASE_ANON;

    /**
     * Returns a Supabase client instance. If the client does not exist,
     * it will be created using the provided URL and anon key. If the
     * Supabase client library is missing, this will return null and log a
     * warning. The client is stored on the NXU_SB namespace so it can
     * be reused across calls without re‑initializing.
     */
    function getSupabaseClient() {
      if (!SUPABASE_URL || !SUPABASE_ANON || !window.supabase) {
        console.warn('Supabase client library, URL, or anon key is missing.');
        return null;
      }
      if (!NXU_SB.client) {
        NXU_SB.client = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
      }
      NXU_SB.hasClient = !!NXU_SB.client;
      return NXU_SB.client;
    }

    function loadState() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        state = JSON.parse(saved);
        state.dashboard = state.dashboard || DEFAULT_STATE.dashboard;
        state.checkTracker = state.checkTracker || DEFAULT_STATE.checkTracker;
        state.calendar = state.calendar || DEFAULT_STATE.calendar;
        state.dashboard.isEditing = false;
        
        // Data migration for older versions
        Object.values(state.dashboard.tiles).forEach(tile => {
            if (tile.template === 'checklist' && tile.data.items && tile.data.items.length > 0 && typeof tile.data.items[0] === 'string') {
                tile.data.items = tile.data.items.map((itemStr, index) => {
                    const isChecked = itemStr.startsWith('[x]');
                    const text = itemStr.replace(/^\[.\]\s*/, '');
                    return { id: (Date.now() + index).toString(), text: text, checked: isChecked };
                });
            }
            ['log', 'paymentLog', 'utilization', 'multiTracker'].forEach(type => {
                const listKey = type === 'utilization' || type === 'multiTracker' ? 'items' : (type === 'paymentLog' ? 'payments' : 'entries');
                if (tile.template === type && Array.isArray(tile.data[listKey])) {
                    tile.data[listKey] = tile.data[listKey].filter(item => item); // Remove null/undefined items
                    tile.data[listKey].forEach((item, index) => {
                        if (!item.id) {
                            item.id = (Date.now() + index).toString();
                        } else {
                            item.id = item.id.toString();
                        }
                    });
                }
            });
        });
        
        return;
      }
      console.log("No unified state found. Attempting to migrate old data...");
      let migrated = false;
      state = JSON.parse(JSON.stringify(DEFAULT_STATE));
      const oldDashboardData = localStorage.getItem(OLD_DASHBOARD_KEY);
      if (oldDashboardData) {
        try {
          const parsed = JSON.parse(oldDashboardData);
          if (parsed.rows && parsed.tiles) {
            state.dashboard = { ...parsed, isEditing: false };
            console.log("Successfully migrated dashboard data.");
            localStorage.removeItem(OLD_DASHBOARD_KEY);
            migrated = true;
          }
        } catch (e) { console.error("Failed to parse old dashboard data:", e); }
      }
      const oldCheckLogData = localStorage.getItem(OLD_CHECKLOG_KEY);
      if (oldCheckLogData) {
        try {
          const parsed = JSON.parse(oldCheckLogData);
          if (parsed.bills && parsed.checkLogs) {
            state.checkTracker = parsed;
            console.log("Successfully migrated check tracker data.");
            localStorage.removeItem(OLD_CHECKLOG_KEY);
            migrated = true;
          }
        } catch (e) { console.error("Failed to parse old check tracker data:", e); }
      }
      if (migrated) {
        console.log("Migration complete. Saving unified state.");
        saveState();
      }
    }
    
    function saveState() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } 
      catch (e) { console.error('Failed to save state:', e); }
    }
    
    // --- Dashboard: Template Definitions ---
    const templates = {
      progress: { name: 'Progress', icon: '📊', fields: [ { name: 'title', label: 'Tracker Name', type: 'text', required: true }, { name: 'current', label: 'Current Value', type: 'number', default: 0 }, { name: 'target', label: 'Target Value', type: 'number', default: 100 }, { name: 'unit', label: 'Unit (optional)', type: 'text', placeholder: 'e.g., tasks, miles' } ] },
      savings: { name: 'Savings', icon: '💰', fields: [ { name: 'title', label: 'Goal Name', type: 'text', required: true }, { name: 'current', label: 'Current Amount', type: 'number', default: 0 }, { name: 'target', label: 'Target Amount', type: 'number', default: 1000 }, { name: 'targetDate', label: 'Target Date', type: 'date' }, { name: 'currency', label: 'Currency', type: 'select', options: ['USD', 'EUR', 'GBP', 'JPY'], default: 'USD' } ] },
      utilization: { name: 'Utilization', icon: '💳', fields: [ { name: 'title', label: 'Tracker Name', type: 'text', required: true }, { name: 'items', label: 'Items to Track', type: 'dynamic-list', itemFields: [ { name: 'name', label: 'Item Name', type: 'text' }, { name: 'used', label: 'Used', type: 'number' }, { name: 'limit', label: 'Limit', type: 'number' } ]}, { name: 'targetUtil', label: 'Target Utilization %', type: 'number', default: 30 }, { name: 'lowerIsBetter', label: 'Lower usage is better (e.g., credit cards)', type: 'checkbox', default: true }, { name: 'sortBy', type: 'sort', options: ['Order Entered', 'Item Name', 'Used', 'Limit', 'Util%'] }, { name: 'sortAscending', type: 'sort-direction' } ] },
      paymentLog: { name: 'Payment Log', icon: '💸', fields: [ { name: 'title', label: 'Log Name', type: 'text', required: true }, { name: 'currency', label: 'Currency', type: 'select', options: ['USD', 'EUR', 'GBP', 'JPY'], default: 'USD' }, { name: 'sortBy', type: 'sort', options: ['Order Entered', 'Date', 'Amount', 'Description'] }, { name: 'sortAscending', type: 'sort-direction' }, { name: 'payments', label: 'Payments', type: 'payment-entries' } ] },
      countdown: { name: 'Countdown', icon: '⏰', fields: [ { name: 'title', label: 'Event Name', type: 'text', required: true }, { name: 'targetDate', label: 'Target Date', type: 'date', required: true }, { name: 'description', label: 'Description', type: 'textarea' } ] },
      checklist: { name: 'Checklist', icon: '✅', fields: [ { name: 'title', label: 'Checklist Name', type: 'text', required: true }, { name: 'recurrence', label: 'Auto-reset tasks', type: 'select', options: ['None', 'Daily', 'Weekly', 'Monthly'], default: 'None' }, { name: 'sortBy', type: 'sort', options: ['Order Entered', 'Task Name', 'Status'] }, { name: 'sortAscending', type: 'sort-direction' }, { name: 'items', label: 'Tasks', type: 'checklist-items' } ] },
      log: { name: 'Log', icon: '📝', fields: [ { name: 'title', label: 'Log Name', type: 'text', required: true }, { name: 'sortBy', type: 'sort', options: ['Order Entered', 'Date'] }, { name: 'sortAscending', type: 'sort-direction' }, { name: 'entries', label: 'Log Entries', type: 'log-entries' } ] },
      multiTracker: { name: 'Multi-Tracker', icon: '📈', fields: [ { name: 'title', label: 'Tracker Name', type: 'text', required: true }, { name: 'items', label: 'Tracked Items', type: 'multi-tracker-items' } ] }
    };

    // --- Bill Categories ---
    // Define categories for recurring bills. Users can assign each bill a category
    // such as Subscription, House, Necessities, Vehicle, and Other. You can
    // extend this array if additional categories are needed.
    const BILL_CATEGORIES = ['Subscription', 'House', 'Necessities', 'Vehicle', 'Other'];
    
    // --- Dashboard: Modal Management ---
    let currentEditId = null, currentAddRowId = null, selectedTemplate = null;
    
    function showAddModal(editId = null, rowId = null) {
      const modal = document.getElementById('tileModal');
      const modalTitle = document.getElementById('modalTitle');
      currentEditId = editId;
      currentAddRowId = rowId;
      if (editId) {
        const tile = state.dashboard.tiles[editId];
        modalTitle.textContent = 'Edit Tracker';
        selectedTemplate = tile.template;
        renderTemplateFields(tile.template, tile.data);
        document.querySelectorAll('.template-card').forEach(card => card.classList.toggle('selected', card.dataset.template === tile.template));
      } else {
        modalTitle.textContent = 'Add New Tracker';
        selectedTemplate = null;
        document.getElementById('templateFields').innerHTML = '';
        document.querySelectorAll('.template-card').forEach(card => card.classList.remove('selected'));
      }
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }
    
    function hideModal(modalId) {
        document.getElementById(modalId).classList.add('hidden');
        if (modalId === 'tileModal') {
            currentEditId = null; selectedTemplate = null; currentAddRowId = null;
        }
    }
    
    // --- Dashboard: Form & Tile Logic ---
    function renderTemplateFields(templateType, existingData = {}) {
      const template = templates[templateType]; if (!template) return;
      const container = document.getElementById('templateFields'); container.innerHTML = '';
      template.fields.forEach(field => {
        const group = document.createElement('div'); group.className = 'form-group mb-4';
        
        if (field.type !== 'checkbox' && field.type !== 'sort' && field.type !== 'sort-direction') {
            const label = document.createElement('label'); 
            label.className = "text-sm font-medium text-slate-300 mb-2 block"; 
            label.textContent = field.label; 
            if (field.required) label.textContent += ' *'; 
            group.appendChild(label);
        }

        if (field.type === 'select') {
          const select = document.createElement('select'); select.name = field.name;
          field.options.forEach(opt => { const option = document.createElement('option'); option.value = opt; option.textContent = opt; select.appendChild(option); });
          select.value = existingData[field.name] || field.default || ''; group.appendChild(select);
        } else if (field.type === 'textarea') {
          const textarea = document.createElement('textarea'); textarea.name = field.name; textarea.value = existingData[field.name] || ''; textarea.className = "min-h-[80px]"; group.appendChild(textarea);
        } else if (field.type === 'dynamic-list') {
          const listContainer = document.createElement('div'); listContainer.className = 'item-list space-y-2'; listContainer.dataset.fieldName = field.name;
          const items = existingData[field.name] || [{}];
          items.forEach(item => addDynamicListItem(listContainer, field.itemFields, item));
          const addBtn = document.createElement('button'); addBtn.className = 'btn btn-secondary mt-2 text-xs px-3 py-1'; addBtn.textContent = '+ Add Item'; addBtn.type = 'button';
          addBtn.onclick = () => addDynamicListItem(listContainer, field.itemFields);
          group.appendChild(listContainer); group.appendChild(addBtn);
        } else if (['checklist-items', 'log-entries', 'payment-entries', 'multi-tracker-items'].includes(field.type)) {
          const note = document.createElement('p'); note.className = 'text-sm text-slate-400'; note.textContent = 'Items can be added after creating the tracker.'; group.appendChild(note);
        } else if (field.type === 'checkbox') {
            const checkLabel = document.createElement('label');
            checkLabel.className = 'flex items-center gap-2 text-sm text-slate-300 cursor-pointer mt-2';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.name = field.name;
            const isChecked = existingData[field.name] === false ? false : (existingData[field.name] === true ? true : field.default);
            input.checked = isChecked;
            input.className = "w-4 h-4 rounded border-teal-600 bg-transparent text-teal-400 focus:ring-teal-400";
            checkLabel.appendChild(input);
            checkLabel.appendChild(document.createTextNode(field.label));
            group.appendChild(checkLabel);
        } else if (field.type === 'sort') {
            group.innerHTML = `<label class="text-sm font-medium text-slate-300 mb-2 block">Sort By</label>`;
            const sortContainer = document.createElement('div');
            sortContainer.className = 'grid grid-cols-2 gap-4';
            const select = document.createElement('select'); select.name = 'sortBy';
            field.options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.replace(/[^a-zA-Z0-9]/g, ''); // Create a safe value
                option.textContent = opt;
                select.appendChild(option);
            });
            select.value = existingData.sortBy || 'OrderEntered';
            const sortDirectionLabel = document.createElement('label');
            sortDirectionLabel.className = 'flex items-center gap-2 text-sm text-slate-300 cursor-pointer';
            const sortDirectionInput = document.createElement('input');
            sortDirectionInput.type = 'checkbox';
            sortDirectionInput.name = 'sortAscending';
            sortDirectionInput.checked = existingData.sortAscending === true;
            sortDirectionLabel.appendChild(sortDirectionInput);
            sortDirectionLabel.appendChild(document.createTextNode('Ascending'));
            
            sortContainer.appendChild(select);
            sortContainer.appendChild(sortDirectionLabel);
            group.appendChild(sortContainer);
        } else if (field.type !== 'sort-direction') {
          const input = document.createElement('input'); input.type = field.type; input.name = field.name; input.placeholder = field.placeholder || ''; input.value = existingData[field.name] || field.default || ''; group.appendChild(input);
        }
        container.appendChild(group);
      });
    }

    function addDynamicListItem(container, itemFields, itemData = {}) {
      const row = document.createElement('div'); row.className = 'item-row flex gap-2 items-center';
      itemFields.forEach(field => {
        const input = document.createElement('input'); 
        input.type = field.type; 
        input.placeholder = field.label; 
        input.value = itemData[field.name] || ''; 
        input.dataset.fieldName = field.name;
        if (field.name === 'name') {
          input.className = "flex-1";
        } else {
          input.className = "w-20";
        }
        row.appendChild(input);
      });
      const removeBtn = document.createElement('button'); removeBtn.className = 'btn btn-danger text-xs px-2 py-1'; removeBtn.textContent = '×'; removeBtn.type = 'button'; removeBtn.onclick = () => row.remove(); row.appendChild(removeBtn);
      container.appendChild(row);
    }
    
    function saveTile() {
        if (!selectedTemplate) { alert('Please select a template'); return; }
        const template = templates[selectedTemplate];
        const data = {};
        const tile = currentEditId ? state.dashboard.tiles[currentEditId] : null;
        const existingData = tile ? tile.data || {} : {};

        template.fields.forEach(field => {
            const input = document.querySelector(`#templateFields [name="${field.name}"]`);
            if (field.type === 'dynamic-list') {
                const container = document.querySelector(`#templateFields [data-field-name="${field.name}"]`);
                if (container) {
                    data[field.name] = Array.from(container.querySelectorAll('.item-row')).map(row => {
                        const item = {};
                        row.querySelectorAll('input').forEach(inp => {
                            if (inp.dataset.fieldName) {
                                item[inp.dataset.fieldName] = inp.type === 'number' ? Number(inp.value) : inp.value;
                            }
                        });
                        return item;
                    });
                } else {
                    data[field.name] = existingData[field.name] || [];
                }
            } else if (['checklist-items', 'log-entries', 'payment-entries', 'multi-tracker-items'].includes(field.type)) {
                const listKeyMap = { 'checklist-items': 'items', 'log-entries': 'entries', 'payment-entries': 'payments', 'multi-tracker-items': 'items'};
                const listKey = listKeyMap[field.type];
                data[listKey] = existingData[listKey] || [];
            } else if (input) {
                if (input.type === 'checkbox') {
                    data[field.name] = input.checked;
                } else if (field.type !== 'sort' && field.type !== 'sort-direction') {
                    data[field.name] = input.type === 'number' ? Number(input.value) : input.value;
                }
            }
        });
        
        const sortByInput = document.querySelector(`#templateFields [name="sortBy"]`);
        if (sortByInput) data.sortBy = sortByInput.value;

        const sortAscInput = document.querySelector(`#templateFields [name="sortAscending"]`);
        if (sortAscInput) data.sortAscending = sortAscInput.checked;

        if (data.items) {
            data.items.forEach((item, index) => {
                if (!item.id) item.id = (Date.now() + index).toString();
            });
        }

        for (const field of template.fields) { if (field.required && !data[field.name]) { alert(`Please fill in ${field.label}`); return; } }
        
        if (currentEditId) {
            state.dashboard.tiles[currentEditId].data = data;
            state.dashboard.tiles[currentEditId].template = selectedTemplate;
        } else {
            const newTile = { id: state.dashboard.nextTileId++, template: selectedTemplate, data: data, created: new Date().toISOString() };
            state.dashboard.tiles[newTile.id] = newTile;
            const row = state.dashboard.rows.find(r => r.id === currentAddRowId);
            if (row) { row.tileIds.push(newTile.id); }
        }
        saveState();
        renderAll();
        hideModal('tileModal');
    }
    
    function deleteTile(id) {
      showConfirmModal('Delete Tracker', 'Are you sure you want to delete this tracker?', () => {
        const rowIndex = state.dashboard.rows.findIndex(row => row.tileIds.includes(id));
        if (rowIndex > -1) {
            state.dashboard.rows[rowIndex].tileIds = state.dashboard.rows[rowIndex].tileIds.filter(tileId => tileId !== id);
            delete state.dashboard.tiles[id];
            if (state.dashboard.rows[rowIndex].tileIds.length === 0) { state.dashboard.rows.splice(rowIndex, 1); }
            saveState(); renderAll();
        }
      });
    }

    // --- Sorting Utility ---
    function applySorting(list, sortBy, sortAscending) {
        if (!Array.isArray(list)) return [];
        const sortedList = [...list];
        const direction = sortAscending ? 1 : -1;

        sortedList.sort((a, b) => {
            let valA, valB;

            switch (sortBy) {
                case 'Date':
                    valA = new Date(a.date || a.timestamp);
                    valB = new Date(b.date || b.timestamp);
                    break;
                case 'Amount':
                    valA = Number(a.amount);
                    valB = Number(b.amount);
                    break;
                case 'Description':
                    valA = (a.description || '').toLowerCase();
                    valB = (b.description || '').toLowerCase();
                    break;
                case 'TaskName':
                    valA = (a.text || '').toLowerCase();
                    valB = (b.text || '').toLowerCase();
                    break;
                case 'Status':
                    valA = a.checked;
                    valB = b.checked;
                    break;
                case 'ItemName':
                    valA = (a.name || '').toLowerCase();
                    valB = (b.name || '').toLowerCase();
                    break;
                case 'Used':
                    valA = Number(a.used);
                    valB = Number(b.used);
                    break;
                case 'Limit':
                    valA = Number(a.limit);
                    valB = Number(b.limit);
                    break;
                case 'Util':
                    valA = (Number(a.used) || 0) / (Number(a.limit) || 1);
                    valB = (Number(b.used) || 0) / (Number(b.limit) || 1);
                    break;
                default:
                    return 0; // No sorting for 'OrderEntered' or unknown
            }

            if (valA < valB) return -1 * direction;
            if (valA > valB) return 1 * direction;
            return 0;
        });

        return sortedList;
    }

    // --- Authentication Modal Logic ---
    /**
     * Displays the authentication modal. When opened, it defaults to the
     * login view. The modal is hidden by default and will be displayed
     * using flexbox to center it in the viewport.
     */
    function showAuthModal() {
        const modal = document.getElementById('authModal');
        if (!modal) return;
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        // default to login view
        showLogin();
    }

    /**
     * Hides the authentication modal. This removes the flex display so
     * the overlay disappears. It is safe to call even if the modal is
     * already hidden.
     */
    function hideAuthModal() {
        const modal = document.getElementById('authModal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }

    /**
     * Shows the login form inside the authentication modal. It hides
     * the signup form and updates the modal title and toggle button
     * accordingly.
     */
    function showLogin() {
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const toggleBtn = document.getElementById('toggleAuthBtn');
        const title = document.getElementById('authModalTitle');
        if (!loginForm || !signupForm || !toggleBtn || !title) return;
        loginForm.classList.remove('hidden');
        signupForm.classList.add('hidden');
        title.textContent = 'Log In';
        toggleBtn.textContent = 'Create Account';
        toggleBtn.onclick = showSignup;
    }

    /**
     * Shows the signup form inside the authentication modal. It hides
     * the login form and updates the modal title and toggle button
     * accordingly.
     */
    function showSignup() {
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        const toggleBtn = document.getElementById('toggleAuthBtn');
        const title = document.getElementById('authModalTitle');
        if (!loginForm || !signupForm || !toggleBtn || !title) return;
        loginForm.classList.add('hidden');
        signupForm.classList.remove('hidden');
        title.textContent = 'Create Account';
        toggleBtn.textContent = 'Back to Login';
        toggleBtn.onclick = showLogin;
    }

    // --- Cloud Sync Functions ---
    /**
     * Saves the current application state to Supabase. It requires the
     * user to be authenticated. If no user is logged in, a warning
     * message will be displayed. The data is stored in a table
     * named `dashboard_data` keyed by the user's ID. If a record
     * already exists for the user it will be updated.
     */
    async function saveDataToCloud() {
        const client = getSupabaseClient();
        if (!client) return;
        try {
            const { data: userData, error: authError } = await client.auth.getUser();
            if (authError || !userData || !userData.user) {
                alert('You must be logged in to save your data.');
                return;
            }
            const user = userData.user;
            const payload = { user_id: user.id, data: state };
            const { error } = await client.from('dashboard_data').upsert(payload, { onConflict: 'user_id' });
            if (error) {
                console.error('Error saving data:', error);
                alert('Failed to save data to cloud.');
            } else {
                alert('Data saved to cloud.');
            }
        } catch (err) {
            console.error('Error saving data:', err);
            alert('Failed to save data to cloud.');
        }
    }

    /**
     * Synchronizes the application state from Supabase. It fetches the
     * record for the currently logged in user and, if found, replaces
     * the local state with the stored data. If no record is found or
     * the user is not logged in, nothing changes. If `isAutoSync` is
     * true, error messages will be suppressed.
     */
    async function syncDataFromCloud(isAutoSync = false) {
        const client = getSupabaseClient();
        if (!client) return;
        try {
            const { data: userData, error: authError } = await client.auth.getUser();
            if (authError || !userData || !userData.user) {
                if (!isAutoSync) alert('You must be logged in to sync your data.');
                return;
            }
            const user = userData.user;
            const { data, error } = await client.from('dashboard_data').select('data').eq('user_id', user.id).maybeSingle();
            if (error) {
                console.error('Error fetching data:', error);
                if (!isAutoSync) alert('Failed to fetch data from cloud.');
                return;
            }
            if (data && data.data) {
                state = data.data;
                saveState();
                renderAll();
            } else if (!isAutoSync) {
                alert('No data found in cloud.');
            }
        } catch (err) {
            console.error('Error syncing data:', err);
            if (!isAutoSync) alert('Failed to sync data from cloud.');
        }
    }

    /**
     * Updates the authentication UI button based on the current login state. If a
     * user is logged in, the button will display "Logged In"; otherwise it
     * shows the default "Log in/Sign Up" label. This should be called on
     * page load and after login or sign‑up events.
     */
    async function updateAuthUI() {
        const client = getSupabaseClient();
        if (!client) return;
        try {
            const { data: userData, error } = await client.auth.getUser();
            const authBtn = document.getElementById('authBtn');
            if (!authBtn) return;
            // Clear any previous inline click handlers
            authBtn.onclick = null;
            if (!error && userData && userData.user) {
                // User is logged in: show Log Out and attach sign out handler
                authBtn.textContent = 'Log Out';
                authBtn.onclick = async () => {
                    try {
                        await client.auth.signOut();
                    } catch (signOutErr) {
                        console.warn('Sign out failed:', signOutErr);
                    }
                    // Clear local dashboard data when logging out to avoid
                    // exposing one user’s data to another. Reset state to
                    // defaults, remove saved state, render the empty app and
                    // update the auth UI.
                    clearDataOnLogout();
                    updateAuthUI();
                };
            } else {
                // User not logged in: show log in and open modal on click
                authBtn.textContent = 'Log in/Sign Up';
                authBtn.onclick = showAuthModal;
            }
        } catch (e) {
            // If there's an error checking user, revert to default label
            const authBtn = document.getElementById('authBtn');
            if (authBtn) {
                authBtn.textContent = 'Log in/Sign Up';
                authBtn.onclick = showAuthModal;
            }
        }
    }
    
    // --- Dashboard: Tile Rendering ---
    function renderTile(tile) {
      const div = document.createElement('div'); 
      div.className = 'tile card p-4';
      div.dataset.tileId = tile.id;

      const header = document.createElement('div'); header.className = 'tile-header flex justify-between items-center mb-3';
      const titleEl = document.createElement('h3'); titleEl.className = "font-semibold"; titleEl.textContent = tile.data.title || 'Untitled'; header.appendChild(titleEl);
      const actions = document.createElement('div'); actions.className = 'tile-actions editing-controls flex gap-1';
      const editBtn = document.createElement('button'); editBtn.className = 'btn btn-secondary p-1.5 h-7 w-7 text-xs'; editBtn.innerHTML = '✏️'; editBtn.onclick = () => showAddModal(tile.id); actions.appendChild(editBtn);
      const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn btn-danger p-1.5 h-7 w-7 text-xs'; deleteBtn.innerHTML = '🗑️'; deleteBtn.onclick = () => deleteTile(tile.id); actions.appendChild(deleteBtn);
      header.appendChild(actions); div.appendChild(header);
      const content = document.createElement('div');
      switch (tile.template) {
        case 'progress': renderProgressContent(content, tile); break;
        case 'savings': renderSavingsContent(content, tile); break;
        case 'utilization': renderUtilizationContent(content, tile); break;
        case 'paymentLog': renderPaymentLogContent(content, tile); break;
        case 'countdown': renderCountdownContent(content, tile); break;
        case 'checklist': renderChecklistContent(content, tile); break;
        case 'log': renderLogContent(content, tile); break;
        case 'multiTracker': renderMultiTrackerContent(content, tile); break;
      }
      div.appendChild(content); return div;
    }
    
    function renderProgressContent(container, tile) {
      const current = Number(tile.data.current) || 0, target = Number(tile.data.target) || 1;
      const progress = Math.min(100, (current / target) * 100);
      container.innerHTML = `<div class="w-full h-2 rounded-full progress-bar-background overflow-hidden"><div class="progress-bar-fill h-full rounded-full" style="width: ${progress}%;"></div></div> <p class="text-sm text-center mt-2">${progress.toFixed(1)}% Complete</p> <div class="grid grid-cols-2 gap-4 mt-3"> <div><p class="text-sm text-slate-300">Current</p><p class="font-semibold text-lg">${current}${tile.data.unit ? ' ' + tile.data.unit : ''}</p></div> <div><p class="text-sm text-slate-300">Target</p><p class="font-semibold text-lg">${target}${tile.data.unit ? ' ' + tile.data.unit : ''}</p></div> </div>`;
    }
    function renderSavingsContent(container, tile) {
      const current = Number(tile.data.current) || 0, target = Number(tile.data.target) || 1;
      const progress = Math.min(100, (current / target) * 100);
      const currency = tile.data.currency || 'USD';
      const formatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: currency, minimumFractionDigits: 0, maximumFractionDigits: 0 });
      let dateInfoHTML = `<div class="text-sm text-slate-300 h-[1.2em] mb-2">&nbsp;</div>`;
      if (tile.data.targetDate) {
        const daysLeft = Math.ceil((new Date(tile.data.targetDate) - new Date()) / (1000 * 60 * 60 * 24));
        dateInfoHTML = `<div class="text-sm text-slate-300 h-[1.2em] mb-2">${daysLeft >= 0 ? `${daysLeft} days remaining` : 'Target date passed'}</div>`;
      }
      container.innerHTML = `${dateInfoHTML} <div class="w-full h-2 rounded-full progress-bar-background overflow-hidden"><div class="progress-bar-fill h-full rounded-full" style="width: ${progress}%;"></div></div> <div class="grid grid-cols-2 gap-4 mt-3"> <div><p class="text-sm text-slate-300">Saved</p><p class="font-semibold text-lg">${formatter.format(current)}</p></div> <div><p class="text-sm text-slate-300">Goal</p><p class="font-semibold text-lg">${formatter.format(target)}</p></div> </div>`;
    }
    function renderUtilizationContent(container, tile) {
        let items = tile.data.items || [];
        if (!state.dashboard.isEditing && tile.data.sortBy && tile.data.sortBy !== 'OrderEntered') {
            items = applySorting(items, tile.data.sortBy, tile.data.sortAscending);
        }
        const targetUtil = Number(tile.data.targetUtil) || 1;
        const lowerIsBetter = tile.data.lowerIsBetter !== false;

        let totalUsed = 0;
        let totalLimit = 0;
        
        (tile.data.items || []).forEach(item => {
            totalUsed += Number(item.used) || 0;
            totalLimit += Number(item.limit) || 0;
        });
        
        const overallUtil = totalLimit > 0 ? (totalUsed / totalLimit * 100) : 0;
        
        let progressWidth = 0;
        let percentageText = '';

        if (lowerIsBetter) {
            const progressMade = 100 - overallUtil;
            const totalProgressPossible = 100 - targetUtil;
            progressWidth = totalProgressPossible > 0 ? Math.max(0, Math.min(100, (progressMade / totalProgressPossible) * 100)) : 0;
            percentageText = `${overallUtil.toFixed(1)}% (Target: ≤${targetUtil}%)`;
        } else {
            progressWidth = Math.min(100, (overallUtil / targetUtil) * 100);
            percentageText = `${overallUtil.toFixed(1)}% (Goal: ≥${targetUtil}%)`;
        }

        const usageText = `Usage: ${totalUsed} of ${totalLimit}`;

        container.innerHTML = `
            <table class="w-full text-sm mb-4">
                <thead>
                    <tr class="text-slate-300 border-b border-teal-700">
                        <th class="text-left font-medium py-2 pr-2">Item</th>
                        <th class="text-right font-medium py-2 px-2">Used</th>
                        <th class="text-right font-medium py-2 px-2">Limit</th>
                        <th class="text-right font-medium py-2 pl-2">Util%</th>
                    </tr>
                </thead>
                <tbody class="list-container" data-tile-id="${tile.id}" data-list-type="items">
                ${items.map(item => {
                    const used = Number(item.used) || 0;
                    const limit = Number(item.limit) || 0;
                    const util = limit > 0 ? (used / limit * 100) : 0;
                    const draggableClass = state.dashboard.isEditing ? 'list-item-draggable' : '';
                    return `<tr class="border-b border-teal-800 last:border-b-0 ${draggableClass}" draggable="${state.dashboard.isEditing}" data-item-id="${item.id}"><td class="py-2 pr-2">${item.name || 'Unnamed'}</td><td class="py-2 px-2 text-right">${used}</td><td class="py-2 px-2 text-right">${limit}</td><td class="py-2 pl-2 text-right">${util.toFixed(0)}%</td></tr>`;
                }).join('')}
                </tbody>
            </table>
            <div>
                <div class="flex justify-between text-xs text-slate-300 mb-1">
                    <span>${usageText}</span>
                    <span>${percentageText}</span>
                </div>
                <div class="w-full h-2 rounded-full progress-bar-background overflow-hidden">
                    <div class="h-full rounded-full progress-bar-fill" style="width: ${progressWidth}%;"></div>
                </div>
            </div>
        `;
    }
    function renderPaymentLogContent(container, tile) {
        let payments = tile.data.payments || [];
        if (!state.dashboard.isEditing && tile.data.sortBy && tile.data.sortBy !== 'OrderEntered') {
            payments = applySorting(payments, tile.data.sortBy, tile.data.sortAscending);
        }
        const currency = tile.data.currency || 'USD';
        const formatter = new Intl.NumberFormat('en-US', { style: 'currency', currency: currency });
        const totalPaid = (tile.data.payments || []).reduce((sum, p) => sum + (Number(p.amount) || 0), 0);

        let entriesHTML = payments.map((entry, index) => {
            const draggableClass = state.dashboard.isEditing ? 'list-item-draggable' : '';
            return `
            <div class="py-2 border-b border-teal-800 flex justify-between items-center text-sm ${draggableClass}" draggable="${state.dashboard.isEditing}" data-item-id="${entry.id}">
                <div>
                    <p>${entry.description}</p>
                    <p class="text-xs text-slate-400">${new Date(entry.date + 'T00:00:00').toLocaleDateString()}</p>
                </div>
                <div class="flex items-center gap-2">
                    <span class="font-semibold">${formatter.format(entry.amount)}</span>
                    <button class="btn btn-danger p-1.5 h-7 w-7 text-xs editing-controls" onclick="deletePaymentEntry(${tile.id}, '${entry.id}')">×</button>
                </div>
            </div>
        `}).join('');

        container.innerHTML = `
            <div class="editing-controls grid grid-cols-1 md:grid-cols-3 gap-2 mb-4 items-end">
                <div class="flex-1">
                    <label class="text-xs text-slate-300 mb-1 block">Description</label>
                    <input type="text" id="payment-desc-${tile.id}" placeholder="e.g., Monthly Payment" class="text-sm">
                </div>
                <div class="flex-1">
                    <label class="text-xs text-slate-300 mb-1 block">Amount</label>
                    <input type="number" id="payment-amount-${tile.id}" placeholder="100.00" class="text-sm">
                </div>
                <div class="flex items-center gap-2">
                     <div class="flex-1">
                        <label class="text-xs text-slate-300 mb-1 block">Date</label>
                        <input type="date" id="payment-date-${tile.id}" value="${new Date().toISOString().split('T')[0]}" class="text-sm">
                    </div>
                    <button class="btn btn-primary h-9 w-9 flex-shrink-0" onclick="addPaymentEntry(${tile.id})">+</button>
                </div>
            </div>
            <div class="max-h-60 overflow-y-auto pr-2 list-container" data-tile-id="${tile.id}" data-list-type="payments">${entriesHTML || '<p class="text-sm text-slate-400">No payments logged yet.</p>'}</div>
            <div class="flex justify-end items-center mt-3 pt-3 border-t border-teal-700">
                <p class="text-sm">Total: <span class="font-bold text-lg">${formatter.format(totalPaid)}</span></p>
            </div>
        `;
    }
    window.addPaymentEntry = (tileId) => {
        const descInput = document.getElementById(`payment-desc-${tileId}`);
        const amountInput = document.getElementById(`payment-amount-${tileId}`);
        const dateInput = document.getElementById(`payment-date-${tileId}`);
        
        if (amountInput && amountInput.value && dateInput && dateInput.value) {
            const tile = state.dashboard.tiles[tileId];
            if (!tile.data.payments) tile.data.payments = [];
            
            tile.data.payments.push({
                id: Date.now().toString(),
                description: descInput.value.trim() || 'Payment',
                amount: Number(amountInput.value),
                date: dateInput.value
            });
            
            descInput.value = '';
            amountInput.value = '';
            dateInput.value = new Date().toISOString().split('T')[0];
            
            saveState();
            renderAll();
        }
    };
    window.deletePaymentEntry = (tileId, entryId) => {
        const tile = state.dashboard.tiles[tileId];
        if (tile && tile.data.payments) {
            tile.data.payments = tile.data.payments.filter(p => p.id !== entryId);
            saveState();
            renderAll();
        }
    };
    function renderCountdownContent(container, tile) {
        const targetDate = new Date(tile.data.targetDate);
        const now = new Date();
        const diff = targetDate - now;
        let countdownText = 'Event has passed';
        if (diff > 0) {
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            countdownText = `${days}d ${hours}h ${minutes}m`;
        }
        container.innerHTML = `<div class="text-center text-3xl font-bold my-4 ${diff <= 0 ? 'text-red-500' : ''}">${countdownText}</div><div class="text-sm text-center text-slate-300">${targetDate.toLocaleDateString()}</div>${tile.data.description ? `<p class="text-sm text-slate-300 mt-3">${tile.data.description}</p>` : ''}`;
    }
    function renderChecklistContent(container, tile) {
        let items = tile.data.items || [];
        if (!state.dashboard.isEditing && tile.data.sortBy && tile.data.sortBy !== 'OrderEntered') {
            items = applySorting(items, tile.data.sortBy, tile.data.sortAscending);
        }
        const checkedCount = (tile.data.items || []).filter(item => item.checked).length;
        const totalCount = (tile.data.items || []).length;
        const progress = totalCount > 0 ? (checkedCount / totalCount * 100) : 0;
        let listHTML = items.map((item, index) => {
            const draggableClass = state.dashboard.isEditing ? 'list-item-draggable' : '';
            let dueDateHTML = '';
            if (item.dueDate) {
                const dueDate = new Date(item.dueDate + 'T00:00:00');
                const today = new Date();
                today.setHours(0,0,0,0);
                let dateClass = 'text-slate-400';
                if (dueDate < today && !item.checked) {
                    dateClass = 'text-red-400 font-semibold'; // Overdue
                }
                dueDateHTML = `<span class="text-xs ml-auto ${dateClass}">${dueDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}</span>`;
            }
            return `<div class="flex items-center mb-2 ${draggableClass}" draggable="${state.dashboard.isEditing}" data-item-id="${item.id}">
                        <label class="flex-1 flex items-center cursor-pointer text-sm">
                            <input type="checkbox" ${item.checked ? 'checked' : ''} onchange="toggleChecklistItem(${tile.id}, '${item.id}', this.checked)" class="mr-3 h-4 w-4 rounded border-teal-600 bg-transparent text-teal-400 focus:ring-teal-400">
                            <span>${item.text}</span>
                        </label>
                        ${dueDateHTML}
                    </div>`;
        }).join('');
        container.innerHTML = `<div class="w-full h-2 rounded-full progress-bar-background overflow-hidden"><div class="progress-bar-fill h-full rounded-full" style="width: ${progress}%;"></div></div><p class="text-sm text-slate-300 my-2">${checkedCount} of ${totalCount} completed</p><div class="max-h-32 overflow-y-auto my-3 pr-2 list-container" data-tile-id="${tile.id}" data-list-type="items">${listHTML}</div>
        <div class="editing-controls flex flex-col sm:flex-row gap-2 mt-2">
            <input type="text" id="checklist-input-${tile.id}" placeholder="Add new task..." class="flex-1 text-sm">
            <div class="flex gap-2">
                <input type="date" id="checklist-date-${tile.id}" class="text-sm w-full sm:w-36">
                <button class="btn btn-primary px-3 py-1 text-sm" onclick="addChecklistItem(${tile.id})">+</button>
            </div>
        </div>`;
    }
    window.toggleChecklistItem = (tileId, itemId, isChecked) => {
        const tile = state.dashboard.tiles[tileId];
        const item = tile.data.items.find(i => i.id == itemId);
        if (item) {
            item.checked = isChecked;
            saveState();
            renderAll();
        }
    };
    window.addChecklistItem = (tileId) => {
        const input = document.getElementById(`checklist-input-${tileId}`);
        const dateInput = document.getElementById(`checklist-date-${tileId}`);
        if (input && input.value.trim()) {
            const tile = state.dashboard.tiles[tileId];
            if (!tile.data.items) tile.data.items = [];
            tile.data.items.push({ 
                id: Date.now().toString(), 
                text: input.value.trim(), 
                checked: false,
                dueDate: dateInput.value || null
            });
            input.value = '';
            dateInput.value = '';
            saveState();
            renderAll();
        }
    };
    function renderLogContent(container, tile) {
        let entries = tile.data.entries || [];
        if (!state.dashboard.isEditing && tile.data.sortBy && tile.data.sortBy !== 'OrderEntered') {
            entries = applySorting(entries, tile.data.sortBy, tile.data.sortAscending);
        }
        let entriesHTML = entries.map((entry, index) => {
            const draggableClass = state.dashboard.isEditing ? 'list-item-draggable' : '';
            return `<div class="py-2 border-b border-teal-800 flex justify-between items-center ${draggableClass}" draggable="${state.dashboard.isEditing}" data-item-id="${entry.id}"><div><p class="text-sm">${entry.text}</p><p class="text-xs text-slate-400">${new Date(entry.timestamp).toLocaleString()}</p></div><button class="btn btn-danger p-1.5 h-7 w-7 text-xs editing-controls" onclick="deleteLogEntry(${tile.id}, '${entry.id}')">×</button></div>`
        }).join('');
        container.innerHTML = `<div class="editing-controls flex gap-2 mb-3"><input type="text" id="log-input-${tile.id}" placeholder="Add new entry..." class="flex-1 text-sm"><button class="btn btn-primary px-3 py-1 text-sm" onclick="addLogEntry(${tile.id})">Add</button></div><div class="max-h-40 overflow-y-auto pr-2 list-container" data-tile-id="${tile.id}" data-list-type="entries">${entriesHTML}</div><div class="flex justify-between items-center mt-2"><p class="text-sm text-slate-300">Total entries: ${entries.length}</p></div>`;
    }
    window.addLogEntry = (tileId) => {
        const input = document.getElementById(`log-input-${tileId}`);
        if (input && input.value.trim()) {
            const tile = state.dashboard.tiles[tileId];
            if (!tile.data.entries) tile.data.entries = [];
            tile.data.entries.unshift({ id: Date.now().toString(), text: input.value.trim(), timestamp: new Date().toISOString() });
            saveState(); renderAll();
        }
    };
    window.deleteLogEntry = (tileId, entryId) => {
        const tile = state.dashboard.tiles[tileId];
        if (tile && tile.data.entries) {
            tile.data.entries = tile.data.entries.filter(e => e.id != entryId);
            saveState();
            renderAll();
        }
    };
    function renderMultiTrackerContent(container, tile) {
        const items = tile.data.items || [];
        container.innerHTML = `
            <div class="space-y-3">${items.map(item => renderMultiTrackerItem(tile.id, item)).join('')}</div>
            <div class="editing-controls mt-4">
                <button class="btn btn-secondary text-xs" onclick="addMultiTrackerItem(${tile.id})">+ Add Item</button>
            </div>
        `;
    }
    function renderMultiTrackerItem(tileId, item) {
        const current = Number(item.current) || 0;
        const target = Number(item.target) || 1;
        const progress = Math.min(100, (current / target) * 100);
        const lowerIsBetter = item.lowerIsBetter || false;
        
        let barClass = 'progress-bar-fill';
        if (lowerIsBetter) {
            if (progress > 80) barClass = 'bg-red-500';
            else if (progress > 50) barClass = 'bg-yellow-400';
        }

        const displayProgress = lowerIsBetter ? 100 - progress : progress;

        return `
            <div class="multi-tracker-item" data-item-id="${item.id}">
                <div class="flex justify-between items-center text-sm mb-1">
                    <span class="font-medium">${item.name || 'Unnamed'}</span>
                    <span class="text-slate-300">${current} / ${target} ${item.unit || ''}</span>
                </div>
                <div class="w-full h-2 rounded-full progress-bar-background overflow-hidden">
                    <div class="${barClass} h-full rounded-full" style="width: ${displayProgress}%;"></div>
                </div>
                <div class="editing-controls flex items-center gap-2 mt-2">
                    <input type="number" value="${current}" onchange="updateMultiTrackerItem(${tileId}, '${item.id}', 'current', this.value)" placeholder="Current" class="text-sm p-1 w-20">
                    <input type="number" value="${target}" onchange="updateMultiTrackerItem(${tileId}, '${item.id}', 'target', this.value)" placeholder="Target" class="text-sm p-1 w-20">
                    <input type="text" value="${item.name || ''}" onchange="updateMultiTrackerItem(${tileId}, '${item.id}', 'name', this.value)" placeholder="Name" class="text-sm p-1 flex-1">
                    <input type="text" value="${item.unit || ''}" onchange="updateMultiTrackerItem(${tileId}, '${item.id}', 'unit', this.value)" placeholder="Unit" class="text-sm p-1 w-20">
                    <label class="flex items-center gap-1 text-xs"><input type="checkbox" ${lowerIsBetter ? 'checked' : ''} onchange="updateMultiTrackerItem(${tileId}, '${item.id}', 'lowerIsBetter', this.checked)"> Lower is Better</label>
                    <button class="btn btn-danger text-xs px-2 py-1" onclick="deleteMultiTrackerItem(${tileId}, '${item.id}')">×</button>
                </div>
            </div>
        `;
    }
    window.addMultiTrackerItem = (tileId) => {
        const tile = state.dashboard.tiles[tileId];
        if (!tile.data.items) tile.data.items = [];
        tile.data.items.push({
            id: Date.now().toString(),
            name: 'New Metric',
            current: 0,
            target: 100,
            unit: '',
            lowerIsBetter: false
        });
        saveState();
        renderAll();
    };
    window.updateMultiTrackerItem = (tileId, itemId, prop, value) => {
        const tile = state.dashboard.tiles[tileId];
        const item = tile.data.items.find(i => i.id === itemId);
        if (item) {
            if (prop === 'current' || prop === 'target') {
                item[prop] = Number(value);
            } else if (prop === 'lowerIsBetter') {
                item[prop] = value;
            } else {
                item[prop] = value;
            }
            saveState();
            renderAll();
        }
    };
    window.deleteMultiTrackerItem = (tileId, itemId) => {
        const tile = state.dashboard.tiles[tileId];
        if (tile && tile.data.items) {
            tile.data.items = tile.data.items.filter(i => i.id !== itemId);
            saveState();
            renderAll();
        }
    };
    
    // --- Dashboard: Row Rendering & Logic ---
    function renderDashboard() {
      const dashboard = document.getElementById('dashboard');
      const emptyState = document.getElementById('emptyState');
      dashboard.innerHTML = '';
      if (state.dashboard.rows.length === 0) {
        emptyState.style.display = 'block';
        dashboard.style.display = 'none';
      } else {
        emptyState.style.display = 'none';
        dashboard.style.display = 'block';
        state.dashboard.rows.forEach(row => {
            const rowDiv = document.createElement('div'); 
            rowDiv.className = 'dashboard-row card p-4 fade-in-up';
            rowDiv.dataset.rowId = row.id;
            const rowHeader = document.createElement('div'); rowHeader.className = 'row-header flex flex-wrap justify-between items-center mb-4 pb-4 border-b border-teal-800';
            const layoutContainer = document.createElement('div'); layoutContainer.className = 'layout-dropdown-container editing-controls relative';
            const layoutButton = document.createElement('button'); layoutButton.className = 'btn btn-secondary text-sm'; layoutButton.innerHTML = `Layout: ${row.layout === 'auto' ? 'Auto' : row.layout} <span class="ml-1">&#9662;</span>`; layoutButton.onclick = (e) => { e.stopPropagation(); toggleLayoutDropdown(row.id); };
            const dropdownMenu = document.createElement('div'); dropdownMenu.id = `layout-dropdown-${row.id}`; dropdownMenu.className = 'layout-dropdown hidden absolute bg-teal-900 border border-teal-700 rounded-md p-1 mt-2 w-36 shadow-lg z-10';
            ['auto', '1', '2', '3', '4'].forEach(l => {
                const item = document.createElement('button'); item.className = 'w-full text-left px-2 py-1.5 text-sm rounded-sm hover:bg-teal-800'; item.textContent = l === 'auto' ? 'Auto' : `${l} Column${l !== '1' ? 's' : ''}`; item.onclick = () => changeRowLayout(row.id, l); dropdownMenu.appendChild(item);
            });
            layoutContainer.appendChild(layoutButton); layoutContainer.appendChild(dropdownMenu);
            const rowActions = document.createElement('div'); rowActions.className = 'actions editing-controls flex gap-2';
            const addTrackerBtn = document.createElement('button'); addTrackerBtn.className = 'btn btn-primary text-sm'; addTrackerBtn.textContent = '+ Add Tracker'; addTrackerBtn.onclick = () => showAddModal(null, row.id);
            const deleteRowBtn = document.createElement('button'); deleteRowBtn.className = 'btn btn-danger text-sm'; deleteRowBtn.textContent = 'Delete Row'; deleteRowBtn.onclick = () => deleteRow(row.id);
            rowActions.appendChild(addTrackerBtn); rowActions.appendChild(deleteRowBtn);
            rowHeader.appendChild(layoutContainer); rowHeader.appendChild(rowActions);
            const gridDiv = document.createElement('div'); gridDiv.className = 'dashboard-grid grid gap-4';
            gridDiv.style.gridTemplateColumns = (row.layout && row.layout !== 'auto') ? `repeat(${row.layout}, 1fr)` : 'repeat(auto-fit, minmax(280px, 1fr))';
            row.tileIds.forEach(tileId => { const tile = state.dashboard.tiles[tileId]; if(tile) gridDiv.appendChild(renderTile(tile)); });
            rowDiv.appendChild(rowHeader); rowDiv.appendChild(gridDiv); dashboard.appendChild(rowDiv);
        });
      }
      document.body.classList.toggle('edit-mode', state.dashboard.isEditing);
      if (state.dashboard.isEditing) {
          // Enable drag-and-drop for both list items and rows when editing
          initListItemDragAndDrop();
          initRowDragAndDrop();
      }
    }

    function toggleEditMode() {
        state.dashboard.isEditing = !state.dashboard.isEditing;
        renderDashboard(); 
        const editBtn = document.getElementById('editDashboardBtn');
        editBtn.textContent = state.dashboard.isEditing ? 'Done Editing' : 'Edit Dashboard';
        editBtn.classList.toggle('btn-primary', state.dashboard.isEditing);
        editBtn.classList.toggle('btn-secondary', !state.dashboard.isEditing);
    }
    
    function addRow() {
        state.dashboard.rows.push({ id: state.dashboard.nextRowId++, layout: 'auto', tileIds: [] });
        saveState(); renderDashboard();
    }

    function customizeDashboard() {
        if (state.dashboard.rows.length === 0) {
            addRow();
        }
        if (!state.dashboard.isEditing) {
            toggleEditMode();
        }
    }

    function deleteRow(rowId) {
        showConfirmModal('Delete Row', 'This will delete the entire row and all its trackers.', () => {
            const row = state.dashboard.rows.find(r => r.id === rowId);
            if (row) {
                row.tileIds.forEach(tileId => { delete state.dashboard.tiles[tileId]; });
                state.dashboard.rows = state.dashboard.rows.filter(r => r.id !== rowId);
                saveState(); renderAll();
            }
        });
    }
    function changeRowLayout(rowId, layout) {
        const row = state.dashboard.rows.find(r => r.id === rowId);
        if (row) { row.layout = layout; saveState(); renderDashboard(); }
    }
    function toggleLayoutDropdown(rowId) {
        document.querySelectorAll('.layout-dropdown').forEach(d => { if (d.id !== `layout-dropdown-${rowId}`) d.classList.add('hidden'); });
        document.getElementById(`layout-dropdown-${rowId}`).classList.toggle('hidden');
    }

    // --- List Item Drag and Drop Logic ---
    function initListItemDragAndDrop() {
        const draggables = document.querySelectorAll('.list-item-draggable');
        const containers = document.querySelectorAll('.list-container');

        draggables.forEach(draggable => {
            draggable.addEventListener('dragstart', () => {
                draggable.classList.add('item-dragging');
            });

            draggable.addEventListener('dragend', () => {
                draggable.classList.remove('item-dragging');
            });
        });

        containers.forEach(container => {
            container.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(container, e.clientY);
                const dragging = document.querySelector('.item-dragging');
                if (dragging && container.contains(dragging)) {
                    if (afterElement == null) {
                        container.appendChild(dragging);
                    } else {
                        container.insertBefore(dragging, afterElement);
                    }

    /**
     * Enables drag-and-drop reordering of dashboard rows when in edit mode. Each
     * row becomes draggable, and dropping a row will reorder the underlying
     * state.dashboard.rows array to reflect the new order. The changes are
     * persisted to localStorage and the dashboard is re-rendered.
     */
    function initRowDragAndDrop() {
        const container = document.getElementById('dashboard');
        if (!container) return;
        const rows = container.querySelectorAll('.dashboard-row');
        rows.forEach(row => {
            // Make rows draggable
            row.setAttribute('draggable', true);
            row.classList.add('row-draggable');
            row.addEventListener('dragstart', () => {
                row.classList.add('item-dragging');
            });
            row.addEventListener('dragend', () => {
                row.classList.remove('item-dragging');
            });
        });
        // Handle dragging over the container
        container.addEventListener('dragover', e => {
            e.preventDefault();
            const afterElement = getDragAfterElementRow(container, e.clientY);
            const dragging = container.querySelector('.dashboard-row.item-dragging');
            if (!dragging) return;
            if (afterElement == null) {
                container.appendChild(dragging);
            } else {
                container.insertBefore(dragging, afterElement);
            }
        });
        // When dropped, update state to reflect new order
        container.addEventListener('drop', e => {
            e.preventDefault();
            const newOrderIds = Array.from(container.children)
                .filter(child => child.classList && child.classList.contains('dashboard-row'))
                .map(row => parseInt(row.dataset.rowId));
            // Reorder the rows array based on newOrderIds
            state.dashboard.rows.sort((a, b) => {
                return newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id);
            });
            saveState();
            renderAll();
        }, { once: true });
    }

    /**
     * Determines the row element that should follow the currently dragged row.
     * This helper mirrors the logic used for list items but targets dashboard
     * rows. It finds the closest row below the cursor.
     */
    function getDragAfterElementRow(container, y) {
        const draggableElements = [...container.querySelectorAll('.dashboard-row:not(.item-dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
    }
                }
            });

            container.addEventListener('drop', e => {
                e.preventDefault();
                const tileId = parseInt(container.dataset.tileId);
                const listType = container.dataset.listType;
                const tile = state.dashboard.tiles[tileId];

                if (!tile || !tile.data[listType]) return;

                const newIdOrder = Array.from(container.children)
                    .map(child => child.dataset.itemId)
                    .filter(id => id);

                const currentList = tile.data[listType].filter(item => item && item.id);

                currentList.sort((a, b) => {
                    return newIdOrder.indexOf(a.id.toString()) - newIdOrder.indexOf(b.id.toString());
                });
                
                tile.data[listType] = currentList;
                
                saveState();
                renderAll(); 
            });
        });
    }

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.list-item-draggable:not(.item-dragging)')];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    // --- Check Tracker: Rendering ---
    function renderBills() {
        const tbody = document.getElementById('billsBody');
        tbody.innerHTML = '';
        // Ensure bills are sorted according to current selected sort field. This is
        // handled by the sortBills function when the user chooses a sort
        // criterion. When renderBills is called independently (e.g., after
        // loading from storage), the current order in state.checkTracker.bills is
        // preserved.
        state.checkTracker.bills.forEach(bill => {
          // Assign a default category if none exists to ensure the dropdown has a value
          if (!bill.category) {
            bill.category = BILL_CATEGORIES[0];
          }
          const tr = document.createElement('tr');
          tr.className = 'border-b border-teal-800 last:border-b-0';
          tr.innerHTML = `
            <td class="p-2"><input type="text" value="${bill.name}" data-id="${bill.id}" data-prop="name" class="bill-input"></td>
            <td class="p-2"><input type="number" value="${bill.amount}" data-id="${bill.id}" data-prop="amount" class="bill-input"></td>
            <td class="p-2"><input type="number" value="${bill.dueDay}" data-id="${bill.id}" data-prop="dueDay" class="bill-input" min="1" max="31"></td>
            <td class="p-2">
                <select data-id="${bill.id}" data-prop="category" class="bill-input">
                    ${BILL_CATEGORIES.map(cat => `<option value="${cat}" ${bill.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                </select>
            </td>
            <td class="p-2">
                <select data-id="${bill.id}" data-prop="type" class="bill-input">
                    <option value="ongoing" ${bill.type === 'ongoing' ? 'selected' : ''}>Ongoing</option>
                    <option value="limited" ${bill.type === 'limited' ? 'selected' : ''}>Limited</option>
                </select>
            </td>
            <td class="p-2"><input type="number" value="${bill.totalToPay || ''}" data-id="${bill.id}" data-prop="totalToPay" class="bill-input" ${bill.type !== 'limited' ? 'disabled' : ''}></td>
            <td class="p-2"><button class="btn btn-danger text-xs" data-id="${bill.id}">Remove</button></td>
          `;
          tbody.appendChild(tr);
        });
    }

    function renderCheckLogs() {
        const container = document.getElementById('checkLogHistory');
        container.innerHTML = '';
        [...state.checkTracker.checkLogs].sort((a,b) => b.id - a.id).forEach(log => {
            // Sort items based on the log's sortBy property before rendering
            sortLogItems(log);
            // Compute totals: projected spending is the sum of all item costs, projected
            // balance is the check amount minus projected spending, total paid is the
            // sum of costs for paid items, and actual balance is check amount minus
            // total paid.
            const projectedSpending = log.items.reduce((sum, item) => sum + (Number(item.cost) || 0), 0);
            const projectedBalance = (Number(log.checkAmount) || 0) - projectedSpending;
            const totalPaid = log.items.reduce((sum, item) => sum + (item.paid ? (Number(item.cost) || 0) : 0), 0);
            const actualBalance = (Number(log.checkAmount) || 0) - totalPaid;

            const card = document.createElement('div');
            card.className = 'card p-4';
            card.dataset.logId = log.id;

            let itemsHtml = log.items.map(item => {
                return `
                    <tr class="${item.paid ? 'text-slate-400 line-through' : ''} border-b border-teal-800 last:border-b-0" data-item-id="${item.id}">
                        <td class="p-2"><input type="checkbox" class="item-paid w-4 h-4" ${item.paid ? 'checked' : ''}></td>
                        <td class="p-2"><input type="text" class="item-input" data-prop="bill" value="${item.bill}"></td>
                        <td class="p-2"><input type="number" class="item-input" data-prop="cost" value="${item.cost}"></td>
                        <td class="p-2"><input type="date" class="item-input" data-prop="dueDate" value="${item.dueDate}"></td>
                        <td class="p-2 running-total text-right"></td>
                        <td class="p-2 running-balance text-right"></td>
                        <td class="p-2"><button class="btn btn-danger remove-item-btn text-xs">X</button></td>
                    </tr>
                `;
            }).join('');

            // Build log card HTML including sort selector and bottom summary
            card.innerHTML = `
                <div class="flex flex-col sm:flex-row flex-wrap justify-between items-center gap-2 mb-4">
                    <div class="flex flex-col gap-1">
                        <h3 class="text-lg font-semibold flex items-center gap-2">
                            ${log.name}
                            ${log.startDate && log.endDate ? `<span class="text-xs text-slate-400">(${formatDateForDisplay(log.startDate)} - ${formatDateForDisplay(log.endDate)})</span>` : ''}
                        </h3>
                        <div class="flex items-center gap-1 mt-1 flex-wrap">
                            <label class="text-xs">Sort by:</label>
                            <select class="log-sort-select text-xs bg-teal-700 text-white p-1 rounded">
                                <option value="bill" ${log.sortBy === 'bill' || !log.sortBy ? 'selected' : ''}>Bill</option>
                                <option value="cost" ${log.sortBy === 'cost' ? 'selected' : ''}>Cost</option>
                                <option value="dueDate" ${log.sortBy === 'dueDate' ? 'selected' : ''}>Due Date</option>
                            </select>
                            <select class="log-order-select text-xs bg-teal-700 text-white p-1 rounded">
                                <option value="asc" ${log.sortOrder === 'asc' || !log.sortOrder ? 'selected' : ''}>Asc</option>
                                <option value="desc" ${log.sortOrder === 'desc' ? 'selected' : ''}>Desc</option>
                            </select>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <button class="btn btn-danger delete-log-btn">Delete Log</button>
                    </div>
                </div>
                <div class="mb-4 max-w-xs">
                    <label class="text-sm text-slate-300 mb-1 block">Check Amount:</label>
                    <input type="number" class="check-amount-input" value="${log.checkAmount || ''}">
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b border-teal-800"><th class="p-2 text-left">Paid</th><th class="p-2 text-left">Bill</th><th class="p-2 text-left">Cost</th><th class="p-2 text-left">Due Date</th><th class="p-2 text-right">Paid Total</th><th class="p-2 text-right">New Balance</th><th></th></tr>
                        </thead>
                        <tbody>${itemsHtml}</tbody>
                    </table>
                </div>
                <div class="mt-4">
                    <button class="btn btn-secondary add-item-btn">+ Add One-Time Bill</button>
                </div>
                <div class="mt-4">
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs">Projected Spending: <strong class="projected-spending">${formatCurrency(projectedSpending)}</strong></span>
                        <span class="text-xs">Projected Balance: <strong class="projected-balance">${formatCurrency(projectedBalance)}</strong></span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm">Total: <strong class="total-paid">${formatCurrency(totalPaid)}</strong></span>
                        <span class="text-sm">Actual Balance: <strong class="actual-balance">${formatCurrency(actualBalance)}</strong></span>
                    </div>
                </div>
            `;
            container.appendChild(card);
            // Update running totals within the table
            updateLogCalculations(log, card);
            // Attach sort handler to this log's sort select
            const sortSelect = card.querySelector('.log-sort-select');
            const orderSelect = card.querySelector('.log-order-select');
            if (sortSelect) {
                sortSelect.onchange = () => {
                    log.sortBy = sortSelect.value;
                    sortLogItems(log);
                    saveState();
                    renderCheckLogs();
                };
            }
            if (orderSelect) {
                orderSelect.onchange = () => {
                    log.sortOrder = orderSelect.value;
                    sortLogItems(log);
                    saveState();
                    renderCheckLogs();
                };
            }
        });
    }

    function renderCalendar() {
        const calendarEl = document.getElementById('calendar');
        const headerEl = document.getElementById('calendar-header');
        calendarEl.innerHTML = '';
        const currentCalendarDate = new Date(state.calendar.currentDate);

        const today = new Date();
        const year = currentCalendarDate.getFullYear();
        const month = currentCalendarDate.getMonth();
        headerEl.textContent = `${currentCalendarDate.toLocaleString('default', { month: 'long' })} ${year}`;

        const firstDayOfMonth = new Date(year, month, 1);
        const lastDayOfMonth = new Date(year, month + 1, 0);
        const firstDayOfWeek = firstDayOfMonth.getDay();

        for (let i = 0; i < firstDayOfWeek; i++) {
            calendarEl.innerHTML += `<div class="calendar-day other-month"></div>`;
        }
        
        for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
            const isToday = day === today.getDate() && month === today.getMonth() && year === today.getFullYear();
            let dayHtml = `<div class="calendar-day ${isToday ? 'today' : ''}"><div class="day-number">${day}</div>`;
            
            state.checkTracker.bills.forEach(bill => {
                if (bill.dueDay == day) {
                    dayHtml += `<div class="event event-bill">${bill.name} - ${formatCurrency(bill.amount)}</div>`;
                }
            });

            Object.values(state.dashboard.tiles).forEach(tile => {
                if (tile.data.targetDate) {
                    const targetDate = new Date(tile.data.targetDate + 'T00:00:00');
                    if (targetDate.getFullYear() === year && targetDate.getMonth() === month && targetDate.getDate() === day) {
                        dayHtml += `<div class="event event-goal">${tile.data.title}</div>`;
                    }
                }
            });

            dayHtml += `</div>`;
            calendarEl.innerHTML += dayHtml;
        }
    }
      
    function renderBillSearch() {
        const select = document.getElementById('billSearchSelect');
        const results = document.getElementById('billHistoryResults');
        const currentSelection = select.value;
        select.innerHTML = '<option value="">Select a bill to see its history</option>';
        results.innerHTML = '';
        
        state.checkTracker.bills.forEach(bill => {
            select.innerHTML += `<option value="${bill.name}">${bill.name}</option>`;
        });
        select.value = currentSelection;
    }

    // --- Check Tracker: Logic ---
    function formatCurrency(n) {
        return (Number(n) || 0).toLocaleString('en-US', { style: 'currency', currency: 'USD' });
    }

    /**
     * Convert an ISO date string (YYYY-MM-DD) into a locale date string using
     * the local timezone. Using new Date(year, monthIndex, day) avoids the
     * UTC interpretation of the Date constructor for ISO strings, which can
     * cause dates to appear a day earlier in certain timezones. This helper
     * ensures dates like "2025-08-27" always render as 8/27/2025 in the
     * user’s locale.
     *
     * @param {string} dateStr ISO date string (YYYY-MM-DD)
     * @returns {string} formatted date string
     */
    function formatDateForDisplay(dateStr) {
        if (!dateStr) return '';
        const parts = dateStr.split('-').map(Number);
        if (parts.length < 3) return dateStr;
        const [year, month, day] = parts;
        // Create date in local timezone to avoid UTC offset issues
        const d = new Date(year, month - 1, day);
        return d.toLocaleDateString();
    }

    /**
     * Sorts the recurring bills based on the specified criteria. This mutates
     * the state.checkTracker.bills array. Valid criteria include 'name',
     * 'amount', 'dueDay', and 'category'. Numeric fields are sorted
     * numerically; string fields are sorted case‑insensitively. After
     * sorting, the updated order is saved to local storage.
     *
     * @param {string} criteria The property by which to sort.
     */
    function sortBills(criteria, order = 'asc') {
        state.checkTracker.bills.sort((a, b) => {
            let result;
            switch (criteria) {
                case 'amount':
                    result = (Number(a.amount) || 0) - (Number(b.amount) || 0);
                    break;
                case 'dueDay':
                    result = (Number(a.dueDay) || 0) - (Number(b.dueDay) || 0);
                    break;
                case 'category':
                    result = (a.category || '').toLowerCase().localeCompare((b.category || '').toLowerCase());
                    break;
                case 'name':
                default:
                    result = (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
                    break;
            }
            return order === 'desc' ? -result : result;
        });
        saveState();
    }

    /**
     * Sorts the items within a check log based on the log's sortBy
     * property. Defaults to 'bill' if no sortBy is set. Valid values
     * include 'bill', 'cost', and 'dueDate'. Sorting mutates the
     * log.items array.
     *
     * @param {Object} log The check log whose items should be sorted.
     */
    function sortLogItems(log) {
        const criteria = log.sortBy || 'bill';
        const order = log.sortOrder || 'asc';
        log.items.sort((a, b) => {
            let result;
            switch (criteria) {
                case 'cost':
                    result = (Number(a.cost) || 0) - (Number(b.cost) || 0);
                    break;
                case 'dueDate': {
                    const da = new Date(a.dueDate);
                    const db = new Date(b.dueDate);
                    result = da - db;
                    break;
                }
                case 'bill':
                default:
                    result = (a.bill || '').toLowerCase().localeCompare((b.bill || '').toLowerCase());
                    break;
            }
            return order === 'desc' ? -result : result;
        });
    }
    function handleBillInputChange(e) {
        const id = parseInt(e.target.dataset.id);
        const prop = e.target.dataset.prop;
        const value = e.target.type === 'number' ? parseFloat(e.target.value) : e.target.value;
        const bill = state.checkTracker.bills.find(b => b.id === id);
        if (bill) {
          bill[prop] = value;
          if (prop === 'type' && value === 'ongoing') {
              delete bill.totalToPay;
          }
          saveState();
          renderCalendar();
          if (prop === 'type') { renderBills(); }
        }
    }
      
    function addBill() {
        const bills = state.checkTracker.bills;
        const newId = (bills.length > 0) ? Math.max(...bills.map(b => b.id)) + 1 : 1;
        bills.push({ id: newId, name: 'New Bill', amount: 0, dueDay: 1, type: 'ongoing', category: BILL_CATEGORIES[0] });
        saveState();
        renderBills();
    }

    function removeBill(id) {
        state.checkTracker.bills = state.checkTracker.bills.filter(b => b.id !== id);
        saveState();
        renderBills();
        renderCalendar(); 
    }

    function addCheckLog(templateType) {
        const now = new Date();
        const logs = state.checkTracker.checkLogs;
        const newId = (logs.length > 0) ? Math.max(...logs.map(l => l.id)) + 1 : 1;
        const isTemplateA = templateType === 'A';
        
        const items = state.checkTracker.bills
            .filter(bill => isTemplateA ? (bill.dueDay >= 1 && bill.dueDay <= 15) : (bill.dueDay >= 16 && bill.dueDay <= 31))
            .map((bill, index) => ({
                id: index + 1,
                bill: bill.name,
                cost: bill.amount,
                dueDate: `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(bill.dueDay).padStart(2, '0')}`,
                paid: false
            }));

        logs.push({
            id: newId,
            name: `Check ${templateType}`,
            month: now.getMonth() + 1,
            year: now.getFullYear(),
            checkAmount: 0,
            items: items
        });
        saveState();
        renderCheckLogs();
    }

    /**
     * Creates a new check log for a bi‑weekly pay schedule. Instead of
     * separate A/B periods, the user enters a pay date and the app
     * automatically includes all recurring bills with due dates within the
     * next 14 days (inclusive). A new log entry is added to
     * state.checkTracker.checkLogs with the selected date encoded in the
     * log name and the items list populated accordingly.
     */
    function addBiWeeklyCheck() {
        const dateInput = document.getElementById('newCheckDate');
        if (!dateInput || !dateInput.value) {
            alert('Please select a paycheck date.');
            return;
        }
        // Parse the entered date string (YYYY-MM-DD) into a local Date. Using
        // the Date constructor with a hyphenated string may interpret the
        // value as UTC, which can shift the date back a day in some
        // timezones. Instead, split the string and construct a Date with
        // year, monthIndex, and day components to ensure the correct local
        // date is used throughout.
        const parts = dateInput.value.split('-').map(Number);
        if (parts.length < 3 || parts.some(isNaN)) {
            alert('Invalid date format.');
            return;
        }
        const payDate = new Date(parts[0], parts[1] - 1, parts[2]);
        // Compute end date for a two‑week pay period. The pay period spans 14
        // days including the pay date. For example, a pay date of Aug 27th
        // should cover bills due through Sept 9th (next pay expected Sept 10th).
        // Therefore we add 13 days to the pay date to get the final due date
        // inclusive. This avoids off‑by‑one issues and ensures bills due on
        // the next pay date are not included.
        const endDate = new Date(payDate);
        endDate.setDate(endDate.getDate() + 13);
        // The end date used for display matches the calculation above.
        const displayEnd = new Date(endDate);
        // Build items from bills due within [payDate, endDate]
        const items = [];
        state.checkTracker.bills.forEach(bill => {
            // Evaluate due date in the starting month
            const year = payDate.getFullYear();
            const startMonth = payDate.getMonth();
            const startDue = new Date(year, startMonth, bill.dueDay);
            if (startDue >= payDate && startDue <= endDate) {
                items.push({
                    id: items.length + 1,
                    bill: bill.name,
                    cost: bill.amount,
                    dueDate: startDue.toISOString().split('T')[0],
                    paid: false
                });
            }
            // Evaluate due date in the next month if the period crosses month boundary
            const endMonth = endDate.getMonth();
            const endYear = endDate.getFullYear();
            if (endMonth !== startMonth) {
                const nextDue = new Date(endYear, endMonth, bill.dueDay);
                if (nextDue >= payDate && nextDue <= endDate) {
                    items.push({
                        id: items.length + 1,
                        bill: bill.name,
                        cost: bill.amount,
                        dueDate: nextDue.toISOString().split('T')[0],
                        paid: false
                    });
                }
            }
        });
        // Create new log entry
        const logs = state.checkTracker.checkLogs;
        const newId = (logs.length > 0) ? Math.max(...logs.map(l => l.id)) + 1 : 1;
        const month = payDate.getMonth() + 1;
        const year = payDate.getFullYear();
        // Label checks sequentially (Check 1, Check 2, etc.) rather than using the date. This
        // avoids confusion when timezone parsing shifts the date. The date
        // range is still displayed separately.
        const checkIndex = logs.length + 1;
        const name = `Check ${checkIndex}`;
        logs.push({
            id: newId,
            name: name,
            month: month,
            year: year,
            items: items,
            // default sorting preferences for new log
            sortBy: 'bill',
            sortOrder: 'asc',
            // Store the start and end of this pay period for display
            startDate: payDate.toISOString().split('T')[0],
            endDate: displayEnd.toISOString().split('T')[0]
        });
        saveState();
        renderAll();
        // Clear the date input after logging
        dateInput.value = '';
    }
      
    function updateLogCalculations(log, logCard) {
        const totalPaid = log.items.reduce((sum, item) => sum + (item.paid ? (item.cost || 0) : 0), 0);
        const overallBalance = (log.checkAmount || 0) - totalPaid;
        // If a balance element exists in the card, update it. Balance may be displayed
        // in various places depending on the UI design. For example, earlier
        // versions placed a .log-balance element in the header. If it's
        // removed (as in the current design), skip this update gracefully.
        const balanceEl = logCard.querySelector('.log-balance');
        if (balanceEl) {
            balanceEl.textContent = formatCurrency(overallBalance);
        }

        // Update bottom summary values: total paid is the sum of costs for paid items
        const totalPaidSum = log.items.reduce((sum, item) => sum + (item.paid ? (Number(item.cost) || 0) : 0), 0);
        const newBalance = (Number(log.checkAmount) || 0) - totalPaidSum;
        const totalPaidEl = logCard.querySelector('.total-paid');
        if (totalPaidEl) totalPaidEl.textContent = formatCurrency(totalPaidSum);
        const newBalEl = logCard.querySelector('.new-balance');
        if (newBalEl) newBalEl.textContent = formatCurrency(newBalance);

        let runningTotal = 0;
        logCard.querySelectorAll('tbody tr').forEach(tr => {
            const itemId = parseInt(tr.dataset.itemId);
            const item = log.items.find(i => i.id === itemId);
            if (!item) return;

            if (item.paid) {
                runningTotal += (item.cost || 0);
                tr.classList.add('text-slate-400', 'line-through');
            } else {
                tr.classList.remove('text-slate-400', 'line-through');
            }
            
            tr.querySelector('.running-total').textContent = formatCurrency(runningTotal);
            tr.querySelector('.running-balance').textContent = formatCurrency((log.checkAmount || 0) - runningTotal);
        });
    }

    function handleCheckLogInteraction(e) {
        const target = e.target;
        const logCard = target.closest('.card[data-log-id]');
        if (!logCard) return;

        const logId = parseInt(logCard.dataset.logId);
        const log = state.checkTracker.checkLogs.find(l => l.id === logId);
        if (!log) return;

        if (target.classList.contains('add-item-btn')) {
            const newItemId = log.items.length > 0 ? Math.max(...log.items.map(i => i.id)) + 1 : 1;
            log.items.push({ id: newItemId, bill: 'One-time expense', cost: 0, dueDate: new Date().toISOString().split('T')[0], paid: false });
            saveState(); renderCheckLogs();
        } else if (target.classList.contains('delete-log-btn')) {
            showConfirmModal('Delete Check Log', 'Are you sure you want to delete this entire check log?', () => {
                state.checkTracker.checkLogs = state.checkTracker.checkLogs.filter(l => l.id !== logId);
                saveState(); renderCheckLogs();
            });
        } else if (target.classList.contains('remove-item-btn')) {
            const itemRow = target.closest('tr[data-item-id]');
            if (itemRow) {
                const itemId = parseInt(itemRow.dataset.itemId);
                log.items = log.items.filter(i => i.id !== itemId);
                saveState(); renderCheckLogs();
            }
        } else if (target.classList.contains('check-amount-input')) {
            log.checkAmount = parseFloat(target.value) || 0;
            saveState(); updateLogCalculations(log, logCard);
        } else {
            const itemRow = target.closest('tr[data-item-id]');
            if (itemRow) {
                const itemId = parseInt(itemRow.dataset.itemId);
                const item = log.items.find(i => i.id === itemId);
                if (item) {
                    if (target.classList.contains('item-paid')) {
                        item.paid = target.checked;
                    } else {
                        const prop = target.dataset.prop;
                        item[prop] = target.type === 'number' ? parseFloat(target.value) : target.value;
                    }
                    saveState(); updateLogCalculations(log, logCard);
                }
            }
        }
    }

    function showBillHistory(billName) {
        const resultsContainer = document.getElementById('billHistoryResults');
        if (!billName) {
            resultsContainer.innerHTML = '';
            return;
        }
        
        let html = '';
        // If a specific bill is selected, show its payment history
        if (billName) {
            html += `<h4 class="font-semibold mb-2">History for ${billName}</h4><ul class="list-disc pl-5 space-y-1 text-sm">`;
            let count = 0;
            state.checkTracker.checkLogs.forEach(log => {
                log.items.forEach(item => {
                    if (item.bill === billName && item.paid) {
                        html += `<li>Paid <strong>${formatCurrency(item.cost)}</strong> on Check ${log.name} (${log.month}/${log.year})</li>`;
                        count++;
                    }
                });
            });
            if (count === 0) {
                html += '<li>No paid history found for this bill.</li>';
            }
            html += '</ul>';
        }
        // Compute total spent by category across all paid items
        const categoryTotals = {};
        // Initialize totals for known categories to 0
        BILL_CATEGORIES.forEach(cat => {
            categoryTotals[cat] = 0;
        });
        // Map bill names to their categories for quick lookup
        const billCategoryMap = {};
        state.checkTracker.bills.forEach(bill => {
            billCategoryMap[bill.name] = bill.category || BILL_CATEGORIES[0];
        });
        state.checkTracker.checkLogs.forEach(log => {
            log.items.forEach(item => {
                if (item.paid) {
                    const category = billCategoryMap[item.bill] || BILL_CATEGORIES[0];
                    categoryTotals[category] += Number(item.cost) || 0;
                }
            });
        });
        html += `<h4 class="font-semibold mt-4">Total Spent by Category</h4><ul class="list-disc pl-5 space-y-1 text-sm">`;
        BILL_CATEGORIES.forEach(cat => {
            const total = categoryTotals[cat] || 0;
            html += `<li>${cat}: <strong>${formatCurrency(total)}</strong></li>`;
        });
        html += '</ul>';
        resultsContainer.innerHTML = html;
    }

    // --- Global Actions & Confirmation ---
    function exportData() {
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `financial-dashboard-export-${new Date().toISOString().split('T')[0]}.json`;
        a.click(); URL.revokeObjectURL(url);
    }

    /**
     * Exports the current application state to a plain text file. The output
     * contains a pretty‑printed JSON representation of the dashboard and
     * associated data, which makes it easier for a large language model (LLM)
     * to process and analyze. The file is downloaded directly in the browser.
     */
    /**
     * Generates a plain‑text summary of the current state. This is not a pure
     * JSON export: it iterates through rows, tiles, bills, and logs and
     * produces a human‑readable description suitable for copy/paste or
     * analysis by an LLM.
     */
    function generatePlainTextSummary() {
        /**
         * Helper to convert a value into a human‑readable string. Objects and
         * arrays are expanded into key:value pairs separated by semicolons.
         */
        function formatValue(val) {
            if (Array.isArray(val)) {
                return val.map(item => {
                    if (item && typeof item === 'object') {
                        return Object.entries(item).map(([k, v]) => `${k}: ${v}`).join(', ');
                    } else {
                        return String(item);
                    }
                }).join('; ');
            } else if (val && typeof val === 'object') {
                return Object.entries(val).map(([k, v]) => `${k}: ${v}`).join(', ');
            } else {
                return String(val);
            }
        }
        const lines = [];
        // Dashboard summary
        lines.push('Dashboard:');
        state.dashboard.rows.forEach((row, rowIndex) => {
            const layout = row.layout || 'auto';
            lines.push(`Row ${rowIndex + 1} (layout: ${layout})`);
            row.tileIds.forEach(tileId => {
                const tile = state.dashboard.tiles[tileId];
                if (!tile) return;
                const title = tile.data.title || 'Untitled';
                lines.push(`  • ${title} (${tile.template})`);
                Object.entries(tile.data).forEach(([key, val]) => {
                    if (key === 'title') return;
                    const valStr = formatValue(val);
                    lines.push(`      - ${key}: ${valStr}`);
                });
            });
        });
        // Check tracker summary
        lines.push('\nCheck Tracker:');
        lines.push(`Bills: ${state.checkTracker.bills.length}`);
        state.checkTracker.bills.forEach((bill, idx) => {
            if (bill && typeof bill === 'object') {
                const billDetails = Object.entries(bill).map(([k, v]) => `${k}: ${v}`).join(', ');
                lines.push(`  • Bill ${idx + 1}: ${billDetails}`);
            } else {
                lines.push(`  • Bill ${idx + 1}: ${String(bill)}`);
            }
        });
        lines.push(`Check Logs: ${state.checkTracker.checkLogs.length}`);
        state.checkTracker.checkLogs.forEach((log, idx) => {
            if (log && typeof log === 'object') {
                const logDetails = Object.entries(log).map(([k, v]) => `${k}: ${v}`).join(', ');
                lines.push(`  • Check Log ${idx + 1}: ${logDetails}`);
            } else {
                lines.push(`  • Check Log ${idx + 1}: ${String(log)}`);
            }
        });
        // Calendar summary
        lines.push('\nCalendar:');
        lines.push(`Current date: ${state.calendar.currentDate}`);
        return lines.join('\n');
    }

    /**
     * Exports the current state to a plain text file and copies it to the
     * clipboard. The exported text is a human‑readable summary generated by
     * generatePlainTextSummary().
     */
    async function exportText() {
        try {
            const textData = generatePlainTextSummary();
            // Attempt to copy to clipboard
            try {
                await navigator.clipboard.writeText(textData);
                alert('Summary copied to clipboard. A text file download will also start.');
            } catch (clipboardErr) {
                console.warn('Clipboard write failed:', clipboardErr);
                alert('Could not copy to clipboard. A text file download will still start.');
            }
            // Download the summary as a .txt file
            const blob = new Blob([textData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `progress_summary_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        } catch (err) {
            console.error('Failed to export summary:', err);
            alert('Failed to export summary.');
        }
    }
    function importData(file) {
        const reader = new FileReader();
        const fileInput = document.getElementById('importFile');
        reader.onload = (e) => {
            try {
                const imported = JSON.parse(e.target.result);
                if (imported.dashboard && imported.checkTracker) {
                    state = { ...DEFAULT_STATE, ...imported };
                    state.dashboard.isEditing = false;
                    saveState();
                    renderAll();
                    const editBtn = document.getElementById('editDashboardBtn');
                    editBtn.textContent = 'Edit Dashboard';
                    editBtn.classList.remove('btn-primary');
                    editBtn.classList.add('btn-secondary');
                } else { alert('Invalid file format. The file must be a valid export from the Unified Financial Dashboard.'); }
            } catch (err) { alert('Failed to import file: ' + err.message); }
            finally {
                fileInput.value = ''; // Reset the file input
            }
        };
        reader.readAsText(file);
    }
    function resetAllData() {
      showConfirmModal('Reset All Data', 'This will delete everything from all tabs. Are you sure?', () => {
        state = JSON.parse(JSON.stringify(DEFAULT_STATE));
        saveState(); 
        renderAll();
        document.getElementById('importFile').value = '';
      });
    }

    /**
     * Clears all dashboard state when a user logs out. This resets the
     * in‑memory state to the DEFAULT_STATE, removes any persisted
     * dashboard state from localStorage, saves the default state back to
     * localStorage for new sessions, and re‑renders the application. This
     * prevents one user’s data from being visible after they log out.
     */
    function clearDataOnLogout() {
        // Reset state to a deep copy of the default
        state = JSON.parse(JSON.stringify(DEFAULT_STATE));
        // Remove persisted state to avoid leakage
        try {
            localStorage.removeItem('nxuDashboardState');
        } catch (err) {
            console.warn('Failed to remove stored state:', err);
        }
        // Persist the default state so unauthenticated users start fresh
        saveState();
        // Re-render UI to reflect cleared data
        renderAll();
    }
    let confirmCallback = null;
    function showConfirmModal(title, text, callback) {
      const modal = document.getElementById('confirmModal');
      document.getElementById('confirmModalTitle').textContent = title;
      document.getElementById('confirmModalText').textContent = text;
      confirmCallback = callback;
      modal.classList.remove('hidden');
      modal.classList.add('flex');
    }
    function hideConfirmModal() {
      document.getElementById('confirmModal').classList.add('hidden');
      confirmCallback = null;
    }

    // --- Recurrence Logic ---
    function checkAndApplyRecurrence(tile) {
        const recurrence = tile.data.recurrence;
        if (!recurrence || recurrence === 'None' || !tile.data.items || tile.data.items.length === 0) {
            return false;
        }

        const lastReset = tile.data.lastReset ? new Date(tile.data.lastReset) : null;
        const now = new Date();

        if (!lastReset) {
            tile.data.lastReset = now.toISOString();
            return false;
        }

        let needsReset = false;
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const lastResetStart = new Date(lastReset.getFullYear(), lastReset.getMonth(), lastReset.getDate());

        switch (recurrence) {
            case 'Daily':
                if (todayStart.getTime() > lastResetStart.getTime()) {
                    needsReset = true;
                }
                break;
            case 'Weekly':
                const oneWeekInMillis = 7 * 24 * 60 * 60 * 1000;
                if (todayStart.getTime() - lastResetStart.getTime() >= oneWeekInMillis) {
                    needsReset = true;
                }
                break;
            case 'Monthly':
                if (now.getFullYear() > lastReset.getFullYear() || now.getMonth() > lastReset.getMonth()) {
                    needsReset = true;
                }
                break;
        }

        if (needsReset) {
            tile.data.items.forEach(item => item.checked = false);
            tile.data.lastReset = todayStart.toISOString();
            return true;
        }
        
        return false;
    }

    function runStartupChecks() {
        let stateModified = false;
        Object.values(state.dashboard.tiles).forEach(tile => {
            if (tile.template === 'checklist') {
                const didReset = checkAndApplyRecurrence(tile);
                if (didReset) {
                    stateModified = true;
                }
            }
        });

        if (stateModified) {
            console.log("Recurring checklists have been reset.");
            saveState();
        }
    }


    // --- Main Rendering & Initialization ---
    function renderAll() {
        renderDashboard();
        renderBills();
        renderCheckLogs();
        renderCalendar();
        renderBillSearch();
    }

    function init() {
        // Setup Template Selector for Dashboard
        const templateSelector = document.querySelector('.template-selector');
        templateSelector.innerHTML = Object.entries(templates).map(([key, {name, icon}]) => `
            <div class="template-card p-3 border border-teal-700 rounded-lg cursor-pointer hover:border-teal-500" data-template="${key}">
                <div class="text-2xl mb-1">${icon}</div>
                <div class="text-xs text-slate-300">${name}</div>
            </div>
        `).join('');

        // Tab Switching
        document.querySelector('.tabs').addEventListener('click', e => {
          if (e.target.classList.contains('tab-btn')) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(e.target.dataset.tab).classList.add('active');
          }
        });

        // Global Actions
        document.getElementById('exportBtn').addEventListener('click', exportData);
        document.getElementById('importFile').addEventListener('change', (e) => { if (e.target.files[0]) { importData(e.target.files[0]); } });
        document.getElementById('resetBtn').addEventListener('click', resetAllData);
        
        // Dashboard Listeners
        document.getElementById('editDashboardBtn').addEventListener('click', toggleEditMode);
        document.getElementById('addRowBtn').addEventListener('click', addRow);
        document.getElementById('addFirstRowBtn').addEventListener('click', customizeDashboard);
        templateSelector.addEventListener('click', (e) => {
          const card = e.target.closest('.template-card');
          if (card) {
            document.querySelectorAll('.template-card').forEach(c => {
                c.classList.remove('bg-teal-800', 'border-teal-400');
            });
            card.classList.add('bg-teal-800', 'border-teal-400');
            selectedTemplate = card.dataset.template;
            renderTemplateFields(selectedTemplate);
          }
        });
        document.getElementById('saveTileBtn').addEventListener('click', saveTile);
        
        // Check Tracker Listeners
        document.getElementById('addBillBtn').onclick = addBill;
        document.getElementById('billsBody').addEventListener('change', handleBillInputChange);
        document.getElementById('billsBody').addEventListener('click', e => {
          if (e.target.tagName === 'BUTTON' && e.target.dataset.id) {
            removeBill(parseInt(e.target.dataset.id));
          }
        });
        // Bill sorting: update order and re-render when sort selection changes
        const billSortSelect = document.getElementById('billSortSelect');
        const billSortOrder = document.getElementById('billSortOrder');
        function updateBillSort() {
            const criterion = billSortSelect ? billSortSelect.value : 'name';
            const order = billSortOrder ? billSortOrder.value : 'asc';
            sortBills(criterion, order);
            renderBills();
        }
        if (billSortSelect) {
            billSortSelect.addEventListener('change', updateBillSort);
        }
        if (billSortOrder) {
            billSortOrder.addEventListener('change', updateBillSort);
        }
        // Bi‑weekly check log: attach event to new button
        const addCheckBtn = document.getElementById('addCheckBtn');
        if (addCheckBtn) {
            addCheckBtn.onclick = addBiWeeklyCheck;
        }
        document.getElementById('checkLogHistory').addEventListener('input', handleCheckLogInteraction);
        document.getElementById('checkLogHistory').addEventListener('click', handleCheckLogInteraction);
        document.getElementById('billSearchSelect').addEventListener('change', e => showBillHistory(e.target.value));

        // Calendar Listeners
        document.getElementById('prevMonth').onclick = () => { 
            const d = new Date(state.calendar.currentDate);
            d.setMonth(d.getMonth() - 1);
            state.calendar.currentDate = d.toISOString();
            saveState(); renderCalendar();
        };
        document.getElementById('nextMonth').onclick = () => { 
            const d = new Date(state.calendar.currentDate);
            d.setMonth(d.getMonth() + 1);
            state.calendar.currentDate = d.toISOString();
            saveState(); renderCalendar();
        };

        // Modal Listeners
        document.getElementById('tileModal').addEventListener('click', (e) => { if (e.target.id === 'tileModal') { hideModal('tileModal'); } });
        document.getElementById('confirmOkBtn').addEventListener('click', () => { if (confirmCallback) { confirmCallback(); } hideConfirmModal(); });
        document.getElementById('confirmCancelBtn').addEventListener('click', hideConfirmModal);
        document.getElementById('confirmModal').addEventListener('click', (e) => { if (e.target.id === 'confirmModal') { hideConfirmModal(); } });
        window.addEventListener('click', (e) => { if (!e.target.closest('.layout-dropdown-container')) { document.querySelectorAll('.layout-dropdown').forEach(d => d.classList.add('hidden')); } });

        // Authentication button will be configured dynamically by updateAuthUI().
        // Do not attach a static click listener here.
        const authModal = document.getElementById('authModal');
        if (authModal) {
            // clicking on the dark backdrop outside the modal content should close it
            authModal.addEventListener('click', (e) => {
                if (e.target.id === 'authModal') {
                    hideAuthModal();
                }
            });
        }
        // Login submission handler
        const loginSubmitBtn = document.getElementById('loginSubmitBtn');
        if (loginSubmitBtn) {
            loginSubmitBtn.addEventListener('click', async () => {
                const client = getSupabaseClient();
                if (!client) return;
                const email = document.getElementById('loginEmail').value.trim();
                const password = document.getElementById('loginPassword').value;
                if (!email || !password) {
                    alert('Please fill out all fields.');
                    return;
                }
                try {
                    const { data, error } = await client.auth.signInWithPassword({ email, password });
                    if (error) {
                        alert(error.message || 'Login failed.');
                        return;
                    }
                    hideAuthModal();
                    await updateAuthUI();
                    await syncDataFromCloud(true);
                } catch (err) {
                    console.error('Login error', err);
                    alert('Login failed.');
                }
            });
        }
        // Signup submission handler
        const signupSubmitBtn = document.getElementById('signupSubmitBtn');
        if (signupSubmitBtn) {
            signupSubmitBtn.addEventListener('click', async () => {
                const client = getSupabaseClient();
                if (!client) return;
                const email = document.getElementById('signupEmail').value.trim();
                const password = document.getElementById('signupPassword').value;
                const confirmPassword = document.getElementById('signupConfirmPassword').value;
                if (!email || !password || !confirmPassword) {
                    alert('Please fill out all fields.');
                    return;
                }
                if (password !== confirmPassword) {
                    alert('Passwords do not match.');
                    return;
                }
                try {
                    // Create the user. When email confirmations are disabled,
                    // Supabase will return a session immediately and the user
                    // will be logged in. When confirmations are enabled,
                    // session will be null until the link is clicked.
                    // Pass the email as "username" in the user metadata so that any
                    // triggers on the profiles table have a non‑null username value.
                    const { data, error } = await client.auth.signUp({
                        email,
                        password,
                        options: {
                            data: { username: email }
                        }
                    });
                    if (error) {
                        alert(error.message || 'Account creation failed.');
                        return;
                    }
                    // After sign up, if a session is returned then the user is
                    // immediately logged in and we can sync the profile and data.
                    // If not, email confirmation may be enabled; in that case
                    // perform a sign in to obtain a session.
                    if (!data.session) {
                        const { error: loginError } = await client.auth.signInWithPassword({ email, password });
                        if (loginError) {
                            console.warn('Login after signup error', loginError);
                        }
                    }
                    // Regardless of how the session was obtained, upsert a row into
                    // the profiles table with id/email/username matching the
                    // user. This avoids NOT NULL violations on username.
                    try {
                        const { data: currentUserData } = await client.auth.getUser();
                        const user = currentUserData && currentUserData.user;
                        if (user) {
                            await client.from('profiles').upsert({ id: user.id, email: email, username: email }, { onConflict: 'id' });
                        }
                    } catch (err) {
                        console.warn('Profile upsert failed:', err);
                    }
                    hideAuthModal();
                    await updateAuthUI();
                    await saveDataToCloud();
                } catch (err) {
                    console.error('Sign up error', err);
                    alert('Account creation failed.');
                }
            });
        }
        // Save data button handler
        const saveBtn = document.getElementById('saveToCloudBtn');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                saveDataToCloud();
            });
        }

        // Export to text button handler
        const exportTextBtn = document.getElementById('exportTextBtn');
        if (exportTextBtn) {
            exportTextBtn.addEventListener('click', () => {
                exportText();
            });
        }

        // Load data and render
        // Update auth button text based on login state on first load
        updateAuthUI();
        loadState();
        runStartupChecks();
        renderAll();
        
        // Set interval to update countdowns
        setInterval(() => {
            if (state.dashboard && state.dashboard.tiles && Object.values(state.dashboard.tiles).some(t => t.template === 'countdown')) {
                renderDashboard();
            }
        }, 1000 * 30);
    }

    // --- Let's Go! ---
    init();
  </script>
</body>
</html>
